var Ye=Object.defineProperty;var Mt=(r,e,t)=>e in r?Ye(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var St=(r,e)=>()=>(r&&(e=r(r=0)),e);var bt=(r,e)=>{for(var t in e)Ye(r,t,{get:e[t],enumerable:!0})};var h=(r,e,t)=>(Mt(r,typeof e!="symbol"?e+"":e,t),t);var st={};bt(st,{cancelPreload:()=>Ue,clearModelCache:()=>Re,deleteCachedModel:()=>Fe,getCachedModel:()=>Le,getModelCacheStats:()=>Oe,getPreloadStatus:()=>Be,getPreloadedModel:()=>qe,isModelCached:()=>Ce,loadModelData:()=>me,preloadModel:()=>Pe,preloadModels:()=>ve});async function ss(r){try{let e=await fetch(r,{method:"HEAD"}),t=e.headers.get("Accept-Ranges"),s=e.headers.get("Content-Length"),n=e.headers.get("ETag")??void 0;return{supports:t==="bytes",size:s?parseInt(s,10):0,etag:n}}catch{return{supports:!1,size:0}}}async function ns(r,e,t,s){let n=new AbortController,o=setTimeout(()=>n.abort(),s);try{let i=await fetch(r,{headers:{Range:`bytes=${e}-${t}`},signal:n.signal});if(i.status!==206&&i.status!==200)throw new Error(`HTTP ${i.status}: ${i.statusText}`);return await i.arrayBuffer()}finally{clearTimeout(o)}}async function rs(r,e){let{chunkSize:t=5*1024*1024,parallelConnections:s=4,timeout:n=3e4,onProgress:o}=e,{supports:i,size:a,etag:c}=await ss(r);if(!i||a<t*2)return tt(r,n,o);let l=await M.getDownloadState(r);if(!l||c&&l.totalSize!==a){let I=Math.ceil(a/t),j=[];for(let P=0;P<I;P++){let K=P*t,Se=Math.min(K+t-1,a-1);j.push({index:P,start:K,end:Se,downloaded:!1})}l={url:r,totalSize:a,downloadedSize:0,chunks:j,startedAt:Date.now()},await M.deleteModel(r)}let u=l.chunks.filter(I=>!I.downloaded),f=l.downloadedSize,w=Date.now(),A=f,x=()=>{if(!o)return;let I=Date.now(),j=(I-w)/1e3,P=f-A,K=j>0?P/j:0,Se=a-f,Tt=K>0?Se/K*1e3:0;o({loaded:f,total:a,percent:f/a*100,speed:K,eta:Tt,currentChunk:l.chunks.filter(It=>It.downloaded).length,totalChunks:l.chunks.length}),w=I,A=f},y=[...u],T=new Map;for(;y.length>0||T.size>0;){for(;y.length>0&&T.size<s;){let I=y.shift(),j=(async()=>{try{let P=await ns(r,I.start,I.end,n);await M.saveChunk(r,I.index,P),I.downloaded=!0,f+=P.byteLength,l.downloadedSize=f,await M.saveDownloadState(l),x()}finally{T.delete(I.index)}})();T.set(I.index,j)}T.size>0&&await Promise.race(T.values())}let S=await M.getChunks(r),R=new Uint8Array(a),Xe=0;for(let I of S)R.set(new Uint8Array(I),Xe),Xe+=I.byteLength;return await M.saveMeta({url:r,size:a,etag:c,cachedAt:Date.now(),chunks:S.length,complete:!0}),await M.deleteDownloadState(r),R.buffer}async function tt(r,e,t){let s=new AbortController,n=setTimeout(()=>s.abort(),e);try{let o=await fetch(r,{signal:s.signal});if(!o.ok)throw new Error(`HTTP ${o.status}: ${o.statusText}`);let i=o.headers.get("Content-Length"),a=i?parseInt(i,10):0;if(!o.body||!t||a===0)return await o.arrayBuffer();let c=o.body.getReader(),l=[],u=0,f=Date.now();for(;;){let{done:A,value:x}=await c.read();if(A)break;l.push(x),u+=x.length;let y=(Date.now()-f)/1e3,T=y>0?u/y:0,S=a-u,R=T>0?S/T*1e3:0;t({loaded:u,total:a,percent:u/a*100,speed:T,eta:R})}let d=new Uint8Array(u),w=0;for(let A of l)d.set(A,w),w+=A.length;return d.buffer}finally{clearTimeout(n)}}async function me(r,e={}){let{cache:t=!0,forceDownload:s=!1,resumable:n=!0}=e;if(t&&!s){let i=await M.getModel(r);if(i)return console.log(`\u2713 Model loaded from cache: ${r}`),e.onProgress?.({loaded:i.byteLength,total:i.byteLength,percent:100,speed:0,eta:0}),i}let o;return n?o=await rs(r,e):o=await tt(r,e.timeout??3e4,e.onProgress),t&&(n||(await M.saveChunk(r,0,o),await M.saveMeta({url:r,size:o.byteLength,cachedAt:Date.now(),chunks:1,complete:!0}))),o}function Pe(r,e={}){return ne.preload(r,e)}function ve(r,e={}){return Promise.all(r.map(({url:t,priority:s})=>ne.preload(t,{...e,priority:s})))}async function Ce(r){return(await M.getMeta(r))?.complete??!1}async function Le(r){return M.getModel(r)}async function Fe(r){return M.deleteModel(r)}async function Re(){return M.clear()}async function Oe(){return M.getStats()}function Be(r){return ne.getStatus(r)}function Ue(r){ne.cancel(r)}async function qe(r){return ne.get(r)}var ts,k,v,C,_e,M,Ne,ne,$e=St(()=>{"use strict";ts="edgeflow-model-cache",k="meta",v="chunks",C="download-state",_e=class{constructor(){h(this,"db",null);h(this,"dbPromise",null)}async openDB(){return this.db?this.db:this.dbPromise?this.dbPromise:(this.dbPromise=new Promise((e,t)=>{let s=indexedDB.open(ts,1);s.onupgradeneeded=n=>{let o=n.target.result;o.objectStoreNames.contains(k)||o.createObjectStore(k,{keyPath:"url"}),o.objectStoreNames.contains(v)||o.createObjectStore(v,{keyPath:["url","index"]}).createIndex("url","url",{unique:!1}),o.objectStoreNames.contains(C)||o.createObjectStore(C,{keyPath:"url"})},s.onsuccess=()=>{this.db=s.result,e(this.db)},s.onerror=()=>t(s.error)}),this.dbPromise)}async getMeta(e){let t=await this.openDB();return new Promise((s,n)=>{let a=t.transaction(k,"readonly").objectStore(k).get(e);a.onsuccess=()=>s(a.result??null),a.onerror=()=>n(a.error)})}async saveMeta(e){let t=await this.openDB();return new Promise((s,n)=>{let o=t.transaction(k,"readwrite");o.objectStore(k).put(e),o.oncomplete=()=>s(),o.onerror=()=>n(o.error)})}async saveChunk(e,t,s){let n=await this.openDB();return new Promise((o,i)=>{let a=n.transaction(v,"readwrite");a.objectStore(v).put({url:e,index:t,data:s}),a.oncomplete=()=>o(),a.onerror=()=>i(a.error)})}async getChunks(e){let t=await this.openDB();return new Promise((s,n)=>{let c=t.transaction(v,"readonly").objectStore(v).index("url").getAll(e);c.onsuccess=()=>{let l=c.result;l.sort((u,f)=>u.index-f.index),s(l.map(u=>u.data))},c.onerror=()=>n(c.error)})}async getModel(e){let t=await this.getMeta(e);if(!t||!t.complete)return null;let s=await this.getChunks(e);if(s.length===0)return null;let n=s.reduce((a,c)=>a+c.byteLength,0),o=new Uint8Array(n),i=0;for(let a of s)o.set(new Uint8Array(a),i),i+=a.byteLength;return o.buffer}async saveDownloadState(e){let t=await this.openDB();return new Promise((s,n)=>{let o=t.transaction(C,"readwrite");o.objectStore(C).put(e),o.oncomplete=()=>s(),o.onerror=()=>n(o.error)})}async getDownloadState(e){let t=await this.openDB();return new Promise((s,n)=>{let a=t.transaction(C,"readonly").objectStore(C).get(e);a.onsuccess=()=>s(a.result??null),a.onerror=()=>n(a.error)})}async deleteDownloadState(e){let t=await this.openDB();return new Promise((s,n)=>{let o=t.transaction(C,"readwrite");o.objectStore(C).delete(e),o.oncomplete=()=>s(),o.onerror=()=>n(o.error)})}async deleteModel(e){let t=await this.openDB();await new Promise((n,o)=>{let i=t.transaction(k,"readwrite");i.objectStore(k).delete(e),i.oncomplete=()=>n(),i.onerror=()=>o(i.error)}),(await this.getChunks(e)).length>0&&await new Promise((n,o)=>{let i=t.transaction(v,"readwrite"),l=i.objectStore(v).index("url").openCursor(IDBKeyRange.only(e));l.onsuccess=u=>{let f=u.target.result;f&&(f.delete(),f.continue())},i.oncomplete=()=>n(),i.onerror=()=>o(i.error)}),await this.deleteDownloadState(e)}async clear(){let e=await this.openDB(),t=[k,v,C];for(let s of t)await new Promise((n,o)=>{let i=e.transaction(s,"readwrite");i.objectStore(s).clear(),i.oncomplete=()=>n(),i.onerror=()=>o(i.error)})}async getStats(){let e=await this.openDB();return new Promise((t,s)=>{let i=e.transaction(k,"readonly").objectStore(k).getAll();i.onsuccess=()=>{let a=i.result;t({models:a.filter(c=>c.complete).length,totalSize:a.reduce((c,l)=>c+(l.complete?l.size:0),0)})},i.onerror=()=>s(i.error)})}},M=new _e;Ne=class{constructor(){h(this,"tasks",new Map);h(this,"queue",[]);h(this,"maxConcurrent",2);h(this,"activeCount",0)}preload(e,t={}){let s=this.tasks.get(e);if(s)return s.promise;let n,o,i=new Promise((l,u)=>{n=l,o=u}),a={url:e,priority:t.priority??0,options:t,promise:i,resolve:n,reject:o,status:"pending"};this.tasks.set(e,a);let c=this.queue.findIndex(l=>{let u=this.tasks.get(l);return u&&u.priority<a.priority});return c===-1?this.queue.push(e):this.queue.splice(c,0,e),this.processQueue(),i}async processQueue(){for(;this.queue.length>0&&this.activeCount<this.maxConcurrent;){let e=this.queue.shift();if(!e)break;let t=this.tasks.get(e);!t||t.status!=="pending"||(this.activeCount++,t.status="loading",this.downloadTask(t).finally(()=>{this.activeCount--,this.processQueue()}))}}async downloadTask(e){try{let t=await me(e.url,e.options);e.status="complete",e.resolve(t)}catch(t){e.status="error",e.reject(t instanceof Error?t:new Error(String(t)))}}isPreloaded(e){return this.tasks.get(e)?.status==="complete"}getStatus(e){return this.tasks.get(e)?.status??"not_found"}async get(e){let t=this.tasks.get(e);return t&&(t.status==="complete"||t.status==="loading")?t.promise:null}cancel(e){let t=this.tasks.get(e);t&&t.status==="pending"&&(this.tasks.delete(e),this.queue=this.queue.filter(s=>s!==e),t.reject(new Error("Preload cancelled")))}clear(){for(let[,e]of this.tasks)e.status==="pending"&&e.reject(new Error("Preload cleared"));this.tasks.clear(),this.queue=[]}},ne=new Ne});var p=class extends Error{constructor(t,s,n){super(t);h(this,"code");h(this,"details");this.code=s,this.details=n,this.name="EdgeFlowError"}},m={RUNTIME_NOT_AVAILABLE:"RUNTIME_NOT_AVAILABLE",RUNTIME_INIT_FAILED:"RUNTIME_INIT_FAILED",RUNTIME_NOT_INITIALIZED:"RUNTIME_NOT_INITIALIZED",MODEL_NOT_FOUND:"MODEL_NOT_FOUND",MODEL_LOAD_FAILED:"MODEL_LOAD_FAILED",MODEL_INVALID_FORMAT:"MODEL_INVALID_FORMAT",MODEL_NOT_LOADED:"MODEL_NOT_LOADED",INFERENCE_FAILED:"INFERENCE_FAILED",INFERENCE_TIMEOUT:"INFERENCE_TIMEOUT",INFERENCE_CANCELLED:"INFERENCE_CANCELLED",OUT_OF_MEMORY:"OUT_OF_MEMORY",MEMORY_LEAK_DETECTED:"MEMORY_LEAK_DETECTED",TENSOR_SHAPE_MISMATCH:"TENSOR_SHAPE_MISMATCH",TENSOR_DTYPE_MISMATCH:"TENSOR_DTYPE_MISMATCH",TENSOR_DISPOSED:"TENSOR_DISPOSED",PIPELINE_NOT_SUPPORTED:"PIPELINE_NOT_SUPPORTED",PIPELINE_INPUT_INVALID:"PIPELINE_INPUT_INVALID",INVALID_ARGUMENT:"INVALID_ARGUMENT",NOT_IMPLEMENTED:"NOT_IMPLEMENTED",UNKNOWN_ERROR:"UNKNOWN_ERROR"};var Et=0;function kt(){return`tensor_${++Et}_${Date.now().toString(36)}`}function fe(r){switch(r){case"float32":return Float32Array;case"float16":return Float32Array;case"int32":return Int32Array;case"int64":return BigInt64Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;default:throw new p(`Unsupported data type: ${r}`,m.INVALID_ARGUMENT,{dtype:r})}}function W(r){return r.length===0?1:r.reduce((e,t)=>e*t,1)}function zt(r){for(let e=0;e<r.length;e++){let t=r[e];if(t===void 0||!Number.isInteger(t)||t<0)throw new p(`Invalid shape dimension at index ${e}: ${t}`,m.INVALID_ARGUMENT,{shape:r,index:e,dimension:t})}}var g=class r{constructor(e,t,s="float32"){h(this,"id");h(this,"dtype");h(this,"shape");h(this,"size");h(this,"_data");h(this,"_isDisposed",!1);zt(t),this.id=kt(),this.dtype=s,this.shape=Object.freeze([...t]),this.size=W(this.shape);let n=this.size;if(e.length!==n)throw new p(`Data length (${e.length}) does not match shape ${JSON.stringify(t)} (expected ${n})`,m.TENSOR_SHAPE_MISMATCH,{dataLength:e.length,expectedSize:n,shape:t});if(e instanceof Array){let o=fe(s);if(this._data=new o(e.length),s==="int64"){let i=this._data;for(let a=0;a<e.length;a++)i[a]=BigInt(Math.round(e[a]??0))}else for(let i=0;i<e.length;i++)this._data[i]=e[i]??0}else this._data=e}get data(){return this.checkDisposed(),this._data}get isDisposed(){return this._isDisposed}checkDisposed(){if(this._isDisposed)throw new p("Cannot access disposed tensor",m.TENSOR_DISPOSED,{tensorId:this.id})}toFloat32Array(){if(this.checkDisposed(),this._data instanceof Float32Array)return this._data;let e=new Float32Array(this.size);for(let t=0;t<this.size;t++)e[t]=Number(this._data[t]??0);return e}toArray(){if(this.checkDisposed(),this.dtype==="int64"){let e=this._data,t=[];for(let s=0;s<e.length;s++)t.push(Number(e[s]));return t}return Array.from(this._data)}clone(){this.checkDisposed();let e=this._data.constructor,t=new e(this._data);return new r(t,this.shape,this.dtype)}dispose(){this._isDisposed||(this._isDisposed=!0,Object.assign(this,{_data:null}))}get(...e){if(this.checkDisposed(),e.length!==this.shape.length)throw new p(`Expected ${this.shape.length} indices, got ${e.length}`,m.INVALID_ARGUMENT,{expectedIndices:this.shape.length,gotIndices:e.length});let t=0,s=1;for(let n=this.shape.length-1;n>=0;n--){let o=e[n]??0,i=this.shape[n]??1;if(o<0||o>=i)throw new p(`Index ${o} out of bounds for dimension ${n} with size ${i}`,m.INVALID_ARGUMENT,{index:o,dimension:n,size:i});t+=o*s,s*=i}return Number(this._data[t]??0)}set(e,...t){if(this.checkDisposed(),t.length!==this.shape.length)throw new p(`Expected ${this.shape.length} indices, got ${t.length}`,m.INVALID_ARGUMENT,{expectedIndices:this.shape.length,gotIndices:t.length});let s=0,n=1;for(let o=this.shape.length-1;o>=0;o--){let i=t[o]??0,a=this.shape[o]??1;if(i<0||i>=a)throw new p(`Index ${i} out of bounds for dimension ${o} with size ${a}`,m.INVALID_ARGUMENT,{index:i,dimension:o,size:a});s+=i*n,n*=a}this._data[s]=e}reshape(e){this.checkDisposed();let t=W(e);if(t!==this.size)throw new p(`Cannot reshape tensor of size ${this.size} to shape ${JSON.stringify(e)} (size ${t})`,m.TENSOR_SHAPE_MISMATCH,{currentSize:this.size,newSize:t,newShape:e});let s=this._data.constructor,n=new s(this._data);return new r(n,e,this.dtype)}transpose(){if(this.checkDisposed(),this.shape.length!==2)throw new p("Transpose is currently only supported for 2D tensors",m.NOT_IMPLEMENTED,{shape:this.shape});let[e,t]=this.shape,s=new Float32Array(this.size);for(let n=0;n<e;n++)for(let o=0;o<t;o++)s[o*e+n]=Number(this._data[n*t+o]??0);return new r(s,[t,e],this.dtype)}toString(){return`Tensor(shape=[${this.shape.join(", ")}], dtype=${this.dtype})`}};function Dt(r,e,t="float32"){if(Array.isArray(r)&&r.length>0&&Array.isArray(r[0])){let n=r.length,o=r[0].length,i=[];for(let a of r){if(a.length!==o)throw new p("Nested arrays must have consistent dimensions",m.INVALID_ARGUMENT);i.push(...a)}return new g(i,e??[n,o],t)}let s=e??[r.length];return new g(r,s,t)}function Qe(r,e="float32"){let t=W(r),s=fe(e),n=new s(t);return new g(n,r,e)}function _t(r,e="float32"){let t=W(r),s=fe(e),n=new s(t);return n.fill(1),new g(n,r,e)}function Nt(r,e,t="float32"){let s=W(r),n=fe(t),o=new n(s);return o.fill(e),new g(o,r,t)}function Pt(r,e="float32"){let t=W(r),s=new Float32Array(t);for(let n=0;n<t;n++)s[n]=Math.random();return new g(s,r,e)}function vt(r,e="float32"){let t=W(r),s=new Float32Array(t);for(let n=0;n<t;n+=2){let o=Math.random(),i=Math.random(),a=Math.sqrt(-2*Math.log(o)),c=2*Math.PI*i;s[n]=a*Math.cos(c),n+1<t&&(s[n+1]=a*Math.sin(c))}return new g(s,r,e)}function Ct(r,e,t=1,s="float32"){e===void 0&&(e=r,r=0);let n=Math.ceil((e-r)/t),o=new Float32Array(n);for(let i=0;i<n;i++)o[i]=r+i*t;return new g(o,[n],s)}function Lt(r,e,t=50,s="float32"){let n=new Float32Array(t),o=(e-r)/(t-1);for(let i=0;i<t;i++)n[i]=r+i*o;return new g(n,[t],s)}function Ft(r,e="float32"){let t=new Float32Array(r*r);for(let s=0;s<r;s++)t[s*r+s]=1;return new g(t,[r,r],e)}function Rt(r,e){if(typeof e=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)+e;return new g(o,r.shape,r.dtype)}if(r.size!==e.size)throw new p("Tensor sizes must match for element-wise operations",m.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:e.shape});let t=new Float32Array(r.size),s=r.toFloat32Array(),n=e.toFloat32Array();for(let o=0;o<r.size;o++)t[o]=(s[o]??0)+(n[o]??0);return new g(t,r.shape,r.dtype)}function Ot(r,e){if(typeof e=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)-e;return new g(o,r.shape,r.dtype)}if(r.size!==e.size)throw new p("Tensor sizes must match for element-wise operations",m.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:e.shape});let t=new Float32Array(r.size),s=r.toFloat32Array(),n=e.toFloat32Array();for(let o=0;o<r.size;o++)t[o]=(s[o]??0)-(n[o]??0);return new g(t,r.shape,r.dtype)}function Bt(r,e){if(typeof e=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)*e;return new g(o,r.shape,r.dtype)}if(r.size!==e.size)throw new p("Tensor sizes must match for element-wise operations",m.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:e.shape});let t=new Float32Array(r.size),s=r.toFloat32Array(),n=e.toFloat32Array();for(let o=0;o<r.size;o++)t[o]=(s[o]??0)*(n[o]??0);return new g(t,r.shape,r.dtype)}function Je(r,e){if(typeof e=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)/e;return new g(o,r.shape,r.dtype)}if(r.size!==e.size)throw new p("Tensor sizes must match for element-wise operations",m.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:e.shape});let t=new Float32Array(r.size),s=r.toFloat32Array(),n=e.toFloat32Array();for(let o=0;o<r.size;o++)t[o]=(s[o]??0)/(n[o]??0);return new g(t,r.shape,r.dtype)}function Ut(r,e){if(r.shape.length!==2||e.shape.length!==2)throw new p("matmul requires 2D tensors",m.INVALID_ARGUMENT,{aShape:r.shape,bShape:e.shape});let[t,s]=r.shape,[n,o]=e.shape;if(s!==n)throw new p(`Matrix dimensions incompatible for multiplication: (${t}x${s}) @ (${n}x${o})`,m.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:e.shape});let i=new Float32Array(t*o),a=r.toFloat32Array(),c=e.toFloat32Array();for(let l=0;l<t;l++)for(let u=0;u<o;u++){let f=0;for(let d=0;d<s;d++)f+=(a[l*s+d]??0)*(c[d*o+u]??0);i[l*o+u]=f}return new g(i,[t,o],r.dtype)}function G(r,e=-1){let t=r.toFloat32Array(),s=new Float32Array(r.size),n=e<0?r.shape.length+e:e;if(n<0||n>=r.shape.length)throw new p(`Invalid axis ${e} for tensor with ${r.shape.length} dimensions`,m.INVALID_ARGUMENT,{axis:e,shape:r.shape});if(r.shape.length===1){let o=-1/0;for(let a=0;a<r.size;a++)(t[a]??0)>o&&(o=t[a]??0);let i=0;for(let a=0;a<r.size;a++)s[a]=Math.exp((t[a]??0)-o),i+=s[a]??0;for(let a=0;a<r.size;a++)s[a]=(s[a]??0)/i;return new g(s,r.shape,r.dtype)}if(r.shape.length===2&&n===1){let[o,i]=r.shape;for(let a=0;a<o;a++){let c=-1/0;for(let u=0;u<i;u++)(t[a*i+u]??0)>c&&(c=t[a*i+u]??0);let l=0;for(let u=0;u<i;u++)s[a*i+u]=Math.exp((t[a*i+u]??0)-c),l+=s[a*i+u]??0;for(let u=0;u<i;u++)s[a*i+u]=(s[a*i+u]??0)/l}return new g(s,r.shape,r.dtype)}throw new p("Softmax currently only supports 1D tensors or 2D tensors along the last axis",m.NOT_IMPLEMENTED,{shape:r.shape,axis:e})}function Ee(r){let e=r.toFloat32Array(),t=new Float32Array(r.size);for(let s=0;s<r.size;s++)t[s]=Math.max(0,e[s]??0);return new g(t,r.shape,r.dtype)}function ke(r){let e=r.toFloat32Array(),t=new Float32Array(r.size);for(let s=0;s<r.size;s++)t[s]=1/(1+Math.exp(-(e[s]??0)));return new g(t,r.shape,r.dtype)}function qt(r){let e=r.toFloat32Array(),t=new Float32Array(r.size);for(let s=0;s<r.size;s++)t[s]=Math.tanh(e[s]??0);return new g(t,r.shape,r.dtype)}function be(r,e){let t=r.toFloat32Array();if(e===void 0){let o=0;for(let i=0;i<r.size;i++)o+=t[i]??0;return o}let s=e<0?r.shape.length+e:e;if(s<0||s>=r.shape.length)throw new p(`Invalid axis ${e} for tensor with ${r.shape.length} dimensions`,m.INVALID_ARGUMENT,{axis:e,shape:r.shape});let n=[...r.shape];if(n.splice(s,1),n.length===0){let o=0;for(let i=0;i<r.size;i++)o+=t[i]??0;return o}if(r.shape.length===2){let[o,i]=r.shape;if(s===0){let a=new Float32Array(i);for(let c=0;c<i;c++)for(let l=0;l<o;l++)a[c]=(a[c]??0)+(t[l*i+c]??0);return new g(a,[i],r.dtype)}else{let a=new Float32Array(o);for(let c=0;c<o;c++)for(let l=0;l<i;l++)a[c]=(a[c]??0)+(t[c*i+l]??0);return new g(a,[o],r.dtype)}}throw new p("Sum along axis currently only supports up to 2D tensors",m.NOT_IMPLEMENTED,{shape:r.shape,axis:e})}function $t(r,e){if(e===void 0)return be(r)/r.size;let t=be(r,e);if(typeof t=="number")return t/(r.shape[e]??1);let s=r.shape[e]??1;return Je(t,s)}function jt(r,e){let t=r.toFloat32Array();if(e===void 0){let n=0,o=t[0]??-1/0;for(let i=1;i<r.size;i++)(t[i]??-1/0)>o&&(o=t[i]??-1/0,n=i);return n}let s=e<0?r.shape.length+e:e;if(r.shape.length===2&&s===1){let[n,o]=r.shape,i=new Float32Array(n);for(let a=0;a<n;a++){let c=0,l=t[a*o]??-1/0;for(let u=1;u<o;u++)(t[a*o+u]??-1/0)>l&&(l=t[a*o+u]??-1/0,c=u);i[a]=c}return new g(i,[n],"int32")}throw new p("Argmax along axis currently only supports 2D tensors along the last axis",m.NOT_IMPLEMENTED,{shape:r.shape,axis:e})}function Wt(r,e=0){if(r.length===0)throw new p("Cannot concatenate empty array of tensors",m.INVALID_ARGUMENT);if(r.length===1)return r[0]?.clone()??Qe([0]);let t=r[0];if(!t)throw new p("First tensor is undefined",m.INVALID_ARGUMENT);let s=e<0?t.shape.length+e:e;for(let i=1;i<r.length;i++){let a=r[i];if(a){if(a.shape.length!==t.shape.length)throw new p("All tensors must have the same number of dimensions",m.TENSOR_SHAPE_MISMATCH);for(let c=0;c<t.shape.length;c++)if(c!==s&&t.shape[c]!==a.shape[c])throw new p(`Shape mismatch at dimension ${c}`,m.TENSOR_SHAPE_MISMATCH)}}let n=[...t.shape],o=0;for(let i of r)i&&(o+=i.shape[s]??0);if(n[s]=o,t.shape.length===1){let i=new Float32Array(o),a=0;for(let c of r)c&&(i.set(c.toFloat32Array(),a),a+=c.size);return new g(i,n,t.dtype)}throw new p("Concatenation currently only supports 1D tensors",m.NOT_IMPLEMENTED)}var ze=class{constructor(e,t,s,n){h(this,"id");h(this,"modelId");h(this,"priority");h(this,"createdAt");h(this,"_status","pending");h(this,"_startedAt");h(this,"_completedAt");h(this,"_result");h(this,"_error");h(this,"_executor");h(this,"_resolvers",[]);h(this,"_cancelled",!1);this.id=e,this.modelId=t,this.priority=s,this.createdAt=Date.now(),this._executor=n}get status(){return this._status}get startedAt(){return this._startedAt}get completedAt(){return this._completedAt}get result(){return this._result}get error(){return this._error}cancel(){if(this._status==="pending"){this._cancelled=!0,this._status="cancelled",this._completedAt=Date.now();let e=new p("Task was cancelled",m.INFERENCE_CANCELLED,{taskId:this.id});for(let{reject:t}of this._resolvers)t(e);this._resolvers=[]}}wait(){return this._status==="completed"?Promise.resolve(this._result):this._status==="failed"?Promise.reject(this._error):this._status==="cancelled"?Promise.reject(new p("Task was cancelled",m.INFERENCE_CANCELLED,{taskId:this.id})):new Promise((e,t)=>{this._resolvers.push({resolve:e,reject:t})})}async execute(){if(!this._cancelled){this._status="running",this._startedAt=Date.now();try{this._result=await this._executor(),this._status="completed",this._completedAt=Date.now();for(let{resolve:e}of this._resolvers)e(this._result)}catch(e){this._error=e instanceof Error?e:new Error(String(e)),this._status="failed",this._completedAt=Date.now();for(let{reject:t}of this._resolvers)t(this._error)}this._resolvers=[]}}},Ze={critical:0,high:1,normal:2,low:3},De=class{constructor(){h(this,"items",[])}get length(){return this.items.length}isEmpty(){return this.items.length===0}enqueue(e){let t=!1;for(let s=0;s<this.items.length;s++){let n=this.items[s];if(n&&Ze[e.priority]<Ze[n.priority]){this.items.splice(s,0,e),t=!0;break}}t||this.items.push(e)}dequeue(){return this.items.shift()}peek(){return this.items[0]}remove(e){let t=this.items.findIndex(s=>s.id===e);if(t!==-1){let[s]=this.items.splice(t,1);return s}}getAll(){return[...this.items]}clear(){this.items=[]}};var Gt=0;function Vt(){return`task_${++Gt}_${Date.now().toString(36)}`}var Ht={maxConcurrentTasks:4,maxConcurrentPerModel:1,defaultTimeout:3e4,enableBatching:!1,maxBatchSize:32,batchTimeout:50},ee=class{constructor(e={}){h(this,"options");h(this,"queues",new Map);h(this,"runningTasks",new Map);h(this,"allTasks",new Map);h(this,"batchers",new Map);h(this,"listeners",new Map);h(this,"globalRunningCount",0);h(this,"isProcessing",!1);h(this,"disposed",!1);this.options={...Ht,...e}}getQueue(e){let t=this.queues.get(e);return t||(t=new De,this.queues.set(e,t)),t}getRunningSet(e){let t=this.runningTasks.get(e);return t||(t=new Set,this.runningTasks.set(e,t)),t}canStartTask(e){if(this.globalRunningCount>=this.options.maxConcurrentTasks)return!1;let t=this.runningTasks.get(e);return!(t&&t.size>=this.options.maxConcurrentPerModel)}async processQueue(){if(this.isProcessing||this.disposed)return;this.isProcessing=!0;try{let t=[];for(let[s,n]of this.queues)for(;!n.isEmpty()&&this.canStartTask(s);){let o=n.dequeue();o&&o.status==="pending"&&(t.push(o),this.getRunningSet(s).add(o.id),this.globalRunningCount++)}await Promise.all(t.map(async s=>{this.emit("inference:start",{taskId:s.id,modelId:s.modelId});try{await s.execute(),this.emit("inference:complete",{taskId:s.id,modelId:s.modelId,duration:(s.completedAt??0)-(s.startedAt??0)})}catch(n){this.emit("inference:error",{taskId:s.id,modelId:s.modelId,error:n})}finally{let n=this.runningTasks.get(s.modelId);n&&n.delete(s.id),this.globalRunningCount--}}))}finally{this.isProcessing=!1}let e=!1;for(let t of this.queues.values())if(!t.isEmpty()){e=!0;break}e&&setTimeout(()=>this.processQueue(),0)}schedule(e,t,s="normal"){if(this.disposed)throw new p("Scheduler has been disposed",m.RUNTIME_NOT_INITIALIZED);let n=new ze(Vt(),e,s,t);return this.allTasks.set(n.id,n),this.getQueue(e).enqueue(n),this.processQueue(),n}scheduleWithTimeout(e,t,s=this.options.defaultTimeout,n="normal"){let o=()=>new Promise((i,a)=>{let c=setTimeout(()=>{a(new p(`Task timed out after ${s}ms`,m.INFERENCE_TIMEOUT,{timeout:s}))},s);t().then(l=>{clearTimeout(c),i(l)}).catch(l=>{clearTimeout(c),a(l)})});return this.schedule(e,o,n)}async scheduleAll(e){let t=e.map(({modelId:s,executor:n,priority:o})=>this.schedule(s,n,o));return Promise.all(t.map(s=>s.wait()))}getTask(e){return this.allTasks.get(e)}cancelTask(e){let t=this.allTasks.get(e);if(t&&t.status==="pending"){t.cancel();for(let s of this.queues.values())s.remove(e);return!0}return!1}cancelAllForModel(e){let t=this.queues.get(e);if(!t)return 0;let s=0;for(let n of t.getAll())n.status==="pending"&&(n.cancel(),s++);return t.clear(),s}getStats(){let e={totalTasks:this.allTasks.size,pendingTasks:0,runningTasks:0,completedTasks:0,failedTasks:0,cancelledTasks:0,queuedByModel:{}};for(let t of this.allTasks.values())switch(t.status){case"pending":e.pendingTasks++;break;case"running":e.runningTasks++;break;case"completed":e.completedTasks++;break;case"failed":e.failedTasks++;break;case"cancelled":e.cancelledTasks++;break}for(let[t,s]of this.queues)e.queuedByModel[t]=s.length;return e}on(e,t){let s=this.listeners.get(e);s||(s=new Set,this.listeners.set(e,s)),s.add(t)}off(e,t){let s=this.listeners.get(e);s&&s.delete(t)}emit(e,t){let s={type:e,timestamp:Date.now(),data:t},n=this.listeners.get(e);if(n)for(let o of n)try{o(s)}catch(i){console.error("Error in event listener:",i)}}clearHistory(){for(let[e,t]of this.allTasks)(t.status==="completed"||t.status==="failed"||t.status==="cancelled")&&this.allTasks.delete(e)}dispose(){this.disposed=!0;for(let e of this.queues.values()){for(let t of e.getAll())t.cancel();e.clear()}for(let e of this.batchers.values())e.clear();this.queues.clear(),this.runningTasks.clear(),this.allTasks.clear(),this.batchers.clear(),this.listeners.clear()}},X=null;function pe(){return X||(X=new ee),X}function et(r){X&&X.dispose(),X=r}function Kt(r){et(new ee(r))}var Xt={initialSize:67108864,maxSize:536870912,growthFactor:1.5,autoGC:!0,gcThreshold:.8},b=class b{constructor(e={}){h(this,"config");h(this,"resources",new Map);h(this,"disposers",new Map);h(this,"listeners",new Map);h(this,"allocated",0);h(this,"peak",0);h(this,"gcScheduled",!1);h(this,"disposed",!1);this.config={...Xt,...e}}static getInstance(){return b.instance||(b.instance=new b),b.instance}static configure(e){b.instance&&console.warn("MemoryManager already initialized, configuration may not apply"),b.instance=new b(e)}track(e,t){if(this.disposed)return;let s=this.estimateTensorSize(e);this.resources.set(e.id,{id:e.id,type:"tensor",size:s,createdAt:Date.now(),stackTrace:this.captureStackTrace()}),t&&this.disposers.set(e.id,t),this.allocated+=s,this.peak=Math.max(this.peak,this.allocated),this.checkMemoryThreshold()}trackModel(e,t){if(this.disposed)return;let s=e.metadata.sizeBytes;this.resources.set(e.id,{id:e.id,type:"model",size:s,createdAt:Date.now(),stackTrace:this.captureStackTrace()}),t&&this.disposers.set(e.id,t),this.allocated+=s,this.peak=Math.max(this.peak,this.allocated),this.checkMemoryThreshold()}untrack(e){let t=this.resources.get(e);t&&(this.allocated-=t.size,this.resources.delete(e),this.disposers.delete(e))}release(e){let t=typeof e=="string"?e:e.id,s=this.disposers.get(t);if(s)try{s()}catch(n){console.error("Error disposing resource:",n)}this.untrack(t)}estimateTensorSize(e){let t=this.getBytesPerElement(e.dtype);return e.size*t}getBytesPerElement(e){switch(e){case"float32":return 4;case"float16":return 2;case"int32":return 4;case"int64":return 8;case"uint8":case"int8":case"bool":return 1;default:return 4}}captureStackTrace(){if(typeof Error.captureStackTrace=="function"){let e={};return Error.captureStackTrace(e,this.captureStackTrace),e.stack}return new Error().stack}checkMemoryThreshold(){if(!this.config.autoGC)return;let e=this.allocated/this.config.maxSize;e>=this.config.gcThreshold&&!this.gcScheduled&&(this.gcScheduled=!0,this.emit("memory:warning",{allocated:this.allocated,maxSize:this.config.maxSize,usage:e}),setTimeout(()=>{this.gc(),this.gcScheduled=!1},0))}gc(){this.emit("memory:gc",{before:this.allocated});let e=Date.now(),t=[];for(let[s,n]of this.resources)e-n.createdAt>5*60*1e3&&t.push(s);this.emit("memory:gc",{after:this.allocated,potentialCleanup:t.length})}getStats(){let e=0,t=0;for(let s of this.resources.values())s.type==="tensor"?e++:t++;return{allocated:this.allocated,used:this.allocated,peak:this.peak,tensorCount:e,modelCount:t}}getResourceDetails(){return Array.from(this.resources.values())}detectLeaks(e=10*60*1e3){let t=Date.now(),s=[];for(let n of this.resources.values())t-n.createdAt>e&&s.push(n);return s}on(e,t){let s=this.listeners.get(e);s||(s=new Set,this.listeners.set(e,s)),s.add(t)}off(e,t){let s=this.listeners.get(e);s&&s.delete(t)}emit(e,t){let s={type:e,timestamp:Date.now(),data:t},n=this.listeners.get(e);if(n)for(let o of n)try{o(s)}catch(i){console.error("Error in event listener:",i)}}resetStats(){this.peak=this.allocated}disposeAll(){for(let e of this.resources.keys())this.release(e)}dispose(){this.disposeAll(),this.disposed=!0,this.listeners.clear(),b.instance=null}};h(b,"instance",null);var V=b,te=class r{constructor(e){h(this,"resources",[]);h(this,"children",[]);h(this,"parent",null);e&&(this.parent=e,e.children.push(this))}track(e){return this.resources.push(e),e}createChild(){return new r(this)}keep(e){let t=this.resources.indexOf(e);return t!==-1&&this.resources.splice(t,1),e}dispose(){for(let e of this.children)e.dispose();this.children=[];for(let e=this.resources.length-1;e>=0;e--)try{this.resources[e]?.dispose()}catch(t){console.error("Error disposing resource in scope:",t)}if(this.resources=[],this.parent){let e=this.parent.children.indexOf(this);e!==-1&&this.parent.children.splice(e,1),this.parent=null}}};async function Yt(r){let e=new te;try{return await r(e)}finally{e.dispose()}}function Qt(r){let e=new te;try{return r(e)}finally{e.dispose()}}var se=class{constructor(e={}){h(this,"maxSize");h(this,"maxModels");h(this,"cache",new Map);h(this,"currentSize",0);this.maxSize=e.maxSize??256*1024*1024,this.maxModels=e.maxModels??5}get(e){let t=this.cache.get(e);if(t)return t.lastAccess=Date.now(),t.model}set(e,t){let s=t.metadata.sizeBytes;for(;(this.currentSize+s>this.maxSize||this.cache.size>=this.maxModels)&&this.cache.size>0;)this.evictLRU();this.cache.set(e,{model:t,size:s,lastAccess:Date.now()}),this.currentSize+=s}delete(e){let t=this.cache.get(e);return t?(t.model.dispose(),this.currentSize-=t.size,this.cache.delete(e),!0):!1}has(e){return this.cache.has(e)}evictLRU(){let e=null,t=1/0;for(let[s,n]of this.cache)n.lastAccess<t&&(t=n.lastAccess,e=s);e&&this.delete(e)}clear(){for(let e of this.cache.values())e.model.dispose();this.cache.clear(),this.currentSize=0}getStats(){return{size:this.currentSize,count:this.cache.size,maxSize:this.maxSize,maxModels:this.maxModels}}};function E(){return V.getInstance()}function Jt(){return V.getInstance().getStats()}function Zt(r){V.getInstance().release(r)}function es(){V.getInstance().gc()}var ge=new Map,O=new Map,je=["webgpu","webnn","wasm"],H=class H{constructor(){h(this,"listeners",new Map);h(this,"defaultRuntime","auto")}static getInstance(){return H.instance||(H.instance=new H),H.instance}register(e,t){ge.set(e,t)}async getRuntime(e="auto"){if(e==="auto")return this.getBestRuntime();let t=O.get(e);if(t)return t;let s=ge.get(e);if(!s)throw new p(`Runtime '${e}' is not registered`,m.RUNTIME_NOT_AVAILABLE,{runtime:e});if(t=s(),!await t.isAvailable())throw new p(`Runtime '${e}' is not available in this environment`,m.RUNTIME_NOT_AVAILABLE,{runtime:e});try{await t.initialize()}catch(o){throw new p(`Failed to initialize runtime '${e}': ${o instanceof Error?o.message:String(o)}`,m.RUNTIME_INIT_FAILED,{runtime:e,error:o})}return O.set(e,t),this.emit("runtime:ready",{runtime:e}),t}async getBestRuntime(){for(let e of je)try{let t=O.get(e);if(t)return t;let s=ge.get(e);if(!s)continue;let n=s();if(await n.isAvailable())return await n.initialize(),O.set(e,n),this.emit("runtime:ready",{runtime:e}),n}catch{continue}throw new p("No runtime available. Please ensure WebGPU, WebNN, or WASM is supported.",m.RUNTIME_NOT_AVAILABLE,{triedRuntimes:je})}async detectAvailableRuntimes(){let e=new Map;for(let t of je){let s=ge.get(t);if(!s){e.set(t,!1);continue}try{let n=s();e.set(t,await n.isAvailable())}catch{e.set(t,!1)}}return e}async getCapabilities(e){return(await this.getRuntime(e)).capabilities}setDefaultRuntime(e){this.defaultRuntime=e}getDefaultRuntimeType(){return this.defaultRuntime}disposeRuntime(e){let t=O.get(e);t&&(t.dispose(),O.delete(e))}disposeAll(){for(let[e,t]of O)t.dispose(),O.delete(e)}on(e,t){let s=this.listeners.get(e);s||(s=new Set,this.listeners.set(e,s)),s.add(t)}off(e,t){let s=this.listeners.get(e);s&&s.delete(t)}emit(e,t){let s={type:e,timestamp:Date.now(),data:t},n=this.listeners.get(e);if(n)for(let o of n)try{o(s)}catch(i){console.error("Error in event listener:",i)}}};h(H,"instance",null);var z=H,os=0;function is(){return`model_${++os}_${Date.now().toString(36)}`}var D=class{constructor(e,t,s){h(this,"id");h(this,"metadata");h(this,"runtime");h(this,"_isLoaded",!0);h(this,"_dispose");this.id=is(),this.metadata=e,this.runtime=t,this._dispose=s}get isLoaded(){return this._isLoaded}dispose(){this._isLoaded&&(this._isLoaded=!1,this._dispose(),E().untrack(this.id))}};async function We(r,e={}){let s=await z.getInstance().getRuntime(e.runtime??"auto"),{loadModelData:n}=await Promise.resolve().then(()=>($e(),st)),o=await n(r,{cache:e.cache??!0,resumable:e.resumable??!0,chunkSize:e.chunkSize,forceDownload:e.forceDownload,onProgress:e.onProgress?a=>{e.onProgress(a.percent/100)}:void 0});return await s.loadModel(o,e)}async function as(r,e={}){return(await z.getInstance().getRuntime(e.runtime??"auto")).loadModel(r,e)}async function Ge(r,e){if(!r.isLoaded)throw new p("Model has been disposed",m.MODEL_NOT_LOADED,{modelId:r.id});let s=await z.getInstance().getRuntime(r.runtime);return pe().schedule(r.id,()=>s.run(r,e)).wait()}async function cs(r,e){let t=pe(),n=await z.getInstance().getRuntime(r.runtime),o=e.map(i=>t.schedule(r.id,()=>n.run(r,i)));return Promise.all(o.map(i=>i.wait()))}function ls(){return z.getInstance()}function re(r,e){z.getInstance().register(r,e)}async function us(){return z.getInstance().getBestRuntime()}async function oe(){return z.getInstance().detectAvailableRuntimes()}var Y={STORAGE:128,COPY_SRC:4,COPY_DST:8,MAP_READ:1},nt={COMPUTE:4},ie=class{constructor(){h(this,"name","webgpu");h(this,"adapter",null);h(this,"device",null);h(this,"models",new Map);h(this,"initialized",!1)}get capabilities(){return{concurrency:!0,quantization:!0,float16:!0,dynamicShapes:!1,maxBatchSize:64,availableMemory:this.device?.limits.maxBufferSize??256*1024*1024}}async isAvailable(){if(typeof navigator>"u"||!navigator.gpu)return!1;try{return await navigator.gpu.requestAdapter()!==null}catch{return!1}}async initialize(){if(!this.initialized){if(!navigator.gpu)throw new p("WebGPU is not supported in this browser",m.RUNTIME_NOT_AVAILABLE);if(this.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),!this.adapter)throw new p("Failed to get WebGPU adapter",m.RUNTIME_INIT_FAILED);this.device=await this.adapter.requestDevice({requiredFeatures:[],requiredLimits:{}}),this.device.lost.then(e=>{console.error("WebGPU device was lost:",e.message),this.initialized=!1,this.device=null}),this.initialized=!0}}async loadModel(e,t={}){this.ensureInitialized();let s=this.parseModelData(e),n={shaders:new Map,pipelines:new Map,weights:new Map,bindGroupLayouts:[],config:s};await this.uploadWeights(e,n),await this.createPipelines(n);let o=`webgpu_${Date.now().toString(36)}`;this.models.set(o,n);let i={name:s.name||t.metadata?.name||"unknown",version:s.version,inputs:s.inputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),outputs:s.outputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),sizeBytes:e.byteLength,quantization:t.quantization??"float32",format:"edgeflow"},a=new D(i,"webgpu",()=>this.unloadModel(o));return E().trackModel(a,()=>a.dispose()),a}async run(e,t){return this.ensureInitialized(),this.executeModel(t,e.metadata)}async executeModel(e,t){let s=this.device,n=[];for(let o of t.outputs){let i=o.shape.reduce((u,f)=>u*f,1),a=s.createBuffer({size:i*4,usage:Y.STORAGE|Y.COPY_SRC}),c=s.createBuffer({size:i*4,usage:Y.MAP_READ|Y.COPY_DST}),l=new Float32Array(i);if(e.length>0&&e[0]){let u=e[0].toFloat32Array();for(let f=0;f<Math.min(i,u.length);f++)l[f]=u[f]??0}n.push(new g(l,o.shape,"float32")),a.destroy(),c.destroy()}return n}parseModelData(e){try{let t=new TextDecoder,s=t.decode(new Uint8Array(e,0,Math.min(1024,e.byteLength)));if(s.trim().startsWith("{")){let n=s.indexOf(`
---
`);n===-1&&(n=e.byteLength);let o=t.decode(new Uint8Array(e,0,n));return JSON.parse(o)}}catch{}return{name:"unknown",version:"1.0.0",layers:[],inputs:[{name:"input",shape:[-1,768],dtype:"float32"}],outputs:[{name:"output",shape:[-1,768],dtype:"float32"}]}}async uploadWeights(e,t){let n=this.device.createBuffer({size:1024,usage:Y.STORAGE|Y.COPY_DST});t.weights.set("default",n)}async createPipelines(e){let t=this.device,n=t.createShaderModule({code:`
      @group(0) @binding(0) var<storage, read> input: array<f32>;
      @group(0) @binding(1) var<storage, read_write> output: array<f32>;
      
      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
        let idx = gid.x;
        if (idx < arrayLength(&input)) {
          output[idx] = input[idx];
        }
      }
    `});e.shaders.set("default",n);let o=t.createBindGroupLayout({entries:[{binding:0,visibility:nt.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:nt.COMPUTE,buffer:{type:"storage"}}]});e.bindGroupLayouts.push(o);let i=t.createPipelineLayout({bindGroupLayouts:[o]}),a=t.createComputePipeline({layout:i,compute:{module:n,entryPoint:"main"}});e.pipelines.set("default",a)}unloadModel(e){let t=this.models.get(e);if(t){for(let s of t.weights.values())s.destroy();this.models.delete(e)}}ensureInitialized(){if(!this.initialized||!this.device)throw new p("WebGPU runtime is not initialized",m.RUNTIME_NOT_INITIALIZED)}dispose(){for(let e of this.models.keys())this.unloadModel(e);this.device&&(this.device.destroy(),this.device=null),this.adapter=null,this.initialized=!1}};function we(){return new ie}var ae=class{constructor(){h(this,"name","webnn");h(this,"context",null);h(this,"models",new Map);h(this,"initialized",!1);h(this,"deviceType","default")}get capabilities(){return{concurrency:!0,quantization:!0,float16:!0,dynamicShapes:!1,maxBatchSize:32,availableMemory:256*1024*1024}}async isAvailable(){if(typeof navigator>"u"||!navigator.ml)return!1;try{return await navigator.ml.createContext({deviceType:"default"})!==null}catch{return!1}}async initialize(){if(!this.initialized){if(!navigator.ml)throw new p("WebNN is not supported in this browser",m.RUNTIME_NOT_AVAILABLE);try{this.context=await navigator.ml.createContext({deviceType:"gpu",powerPreference:"high-performance"}),this.deviceType="gpu"}catch{try{this.context=await navigator.ml.createContext({deviceType:"cpu"}),this.deviceType="cpu"}catch(e){throw new p(`Failed to create WebNN context: ${e instanceof Error?e.message:String(e)}`,m.RUNTIME_INIT_FAILED)}}this.initialized=!0}}async loadModel(e,t={}){this.ensureInitialized();let s=this.parseModelConfig(e),n=`webnn_${Date.now().toString(36)}`,o={name:s.name||t.metadata?.name||"unknown",version:s.version||"1.0.0",inputs:s.inputs.map(a=>({name:a.name,dtype:a.dtype,shape:a.shape})),outputs:s.outputs.map(a=>({name:a.name,dtype:a.dtype,shape:a.shape})),sizeBytes:e.byteLength,quantization:t.quantization??"float32",format:"edgeflow"},i=new D(o,"webnn",()=>this.unloadModel(n));return E().trackModel(i,()=>i.dispose()),i}async run(e,t){return this.ensureInitialized(),this.executeModel(t,e.metadata)}async executeModel(e,t){let s=[];for(let n of t.outputs){let o=n.shape.reduce((a,c)=>a*c,1),i=new Float32Array(o);if(e.length>0&&e[0]){let a=e[0].toFloat32Array();for(let c=0;c<Math.min(o,a.length);c++)i[c]=a[c]??0}s.push(new g(i,n.shape,"float32"))}return s}parseModelConfig(e){try{let t=new TextDecoder,s=t.decode(new Uint8Array(e,0,Math.min(1024,e.byteLength)));if(s.trim().startsWith("{")){let n=s.indexOf(`
---
`);n===-1&&(n=e.byteLength);let o=t.decode(new Uint8Array(e,0,n));return JSON.parse(o)}}catch{}return{name:"unknown",version:"1.0.0",inputs:[{name:"input",shape:[-1,768],dtype:"float32"}],outputs:[{name:"output",shape:[-1,768],dtype:"float32"}]}}unloadModel(e){this.models.delete(e)}ensureInitialized(){if(!this.initialized||!this.context)throw new p("WebNN runtime is not initialized",m.RUNTIME_NOT_INITIALIZED)}getDeviceType(){return this.deviceType}dispose(){this.models.clear(),this.context=null,this.initialized=!1}};function ye(){return new ae}var ce=class{constructor(){h(this,"name","wasm");h(this,"module",null);h(this,"simdSupported",!1);h(this,"models",new Map);h(this,"initialized",!1)}get capabilities(){return{concurrency:!1,quantization:!0,float16:!1,dynamicShapes:!0,maxBatchSize:16,availableMemory:128*1024*1024}}async isAvailable(){if(typeof WebAssembly>"u")return!1;try{let e=new Uint8Array([0,97,115,109,1,0,0,0]);return await WebAssembly.instantiate(e),!0}catch{return!1}}async initialize(){if(this.initialized)return;this.simdSupported=await this.checkSIMDSupport();let e=new WebAssembly.Memory({initial:256,maximum:2048});this.module={memory:e,exports:this.createJSFallback(e)},this.initialized=!0}async checkSIMDSupport(){try{let e=new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,253,12,0,0,0,0,11]);return await WebAssembly.instantiate(e),!0}catch{return!1}}createJSFallback(e){let t=0,s=new Map;return{malloc:n=>{let o=t;return t+=n,s.set(o,n),o},free:n=>{s.delete(n)},matmul_f32:(n,o,i,a,c,l,u)=>{let f=new Float32Array(e.buffer),d=n/4,w=a/4,A=u/4;for(let x=0;x<o;x++)for(let y=0;y<l;y++){let T=0;for(let S=0;S<i;S++)T+=(f[d+x*i+S]??0)*(f[w+S*l+y]??0);f[A+x*l+y]=T}},add_f32:(n,o,i,a)=>{let c=new Float32Array(e.buffer),l=n/4,u=o/4,f=i/4;for(let d=0;d<a;d++)c[f+d]=(c[l+d]??0)+(c[u+d]??0)},mul_f32:(n,o,i,a)=>{let c=new Float32Array(e.buffer),l=n/4,u=o/4,f=i/4;for(let d=0;d<a;d++)c[f+d]=(c[l+d]??0)*(c[u+d]??0)},relu_f32:(n,o,i)=>{let a=new Float32Array(e.buffer),c=n/4,l=o/4;for(let u=0;u<i;u++)a[l+u]=Math.max(0,a[c+u]??0)},sigmoid_f32:(n,o,i)=>{let a=new Float32Array(e.buffer),c=n/4,l=o/4;for(let u=0;u<i;u++)a[l+u]=1/(1+Math.exp(-(a[c+u]??0)))},softmax_f32:(n,o,i)=>{let a=new Float32Array(e.buffer),c=n/4,l=o/4,u=-1/0;for(let d=0;d<i;d++)(a[c+d]??0)>u&&(u=a[c+d]??0);let f=0;for(let d=0;d<i;d++)a[l+d]=Math.exp((a[c+d]??0)-u),f+=a[l+d]??0;for(let d=0;d<i;d++)a[l+d]=(a[l+d]??0)/f}}}async loadModel(e,t={}){this.ensureInitialized();let s=this.parseModelConfig(e),n={weights:new Map,config:s,executionOrder:s.layers.map(c=>c.name)};await this.loadWeights(e,n);let o=`wasm_${Date.now().toString(36)}`;this.models.set(o,n);let i={name:s.name||t.metadata?.name||"unknown",version:s.version||"1.0.0",inputs:s.inputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),outputs:s.outputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),sizeBytes:e.byteLength,quantization:t.quantization??"float32",format:"edgeflow"},a=new D(i,"wasm",()=>this.unloadModel(o));return E().trackModel(a,()=>a.dispose()),a}async run(e,t){return this.ensureInitialized(),this.executeModel(t,e.metadata)}async executeModel(e,t){let s=[];for(let n of t.outputs){let o=n.shape.reduce((a,c)=>a*c,1),i;if(e.length>0&&e[0]){let a=e[0];if(n.name.includes("logits")||n.name.includes("class"))i=G(a);else if(n.name.includes("relu"))i=Ee(a);else if(n.name.includes("sigmoid"))i=ke(a);else{let c=new Float32Array(o),l=a.toFloat32Array();for(let u=0;u<Math.min(o,l.length);u++)c[u]=l[u]??0;i=new g(c,n.shape,"float32")}}else i=new g(new Float32Array(o),n.shape,"float32");s.push(i)}return s}parseModelConfig(e){try{let t=new TextDecoder,s=t.decode(new Uint8Array(e,0,Math.min(2048,e.byteLength)));if(s.trim().startsWith("{")){let n=s.indexOf(`
---
`);if(n===-1)try{return JSON.parse(s)}catch{n=e.byteLength}let o=t.decode(new Uint8Array(e,0,n));return JSON.parse(o)}}catch{}return{name:"unknown",version:"1.0.0",layers:[],inputs:[{name:"input",shape:[-1,768],dtype:"float32"}],outputs:[{name:"output",shape:[-1,768],dtype:"float32"}]}}async loadWeights(e,t){}unloadModel(e){let t=this.models.get(e);if(t&&this.module)for(let s of t.weights.values())this.module.exports.free(s.ptr);this.models.delete(e)}ensureInitialized(){if(!this.initialized||!this.module)throw new p("WASM runtime is not initialized",m.RUNTIME_NOT_INITIALIZED)}hasSIMDSupport(){return this.simdSupported}dispose(){for(let e of this.models.keys())this.unloadModel(e);this.module=null,this.initialized=!1}};function rt(){return new ce}var it="1.17.0",Ae=`https://cdn.jsdelivr.net/npm/onnxruntime-web@${it}/dist/`,ot=`${Ae}ort.min.js`,_=null,xe=null;async function hs(){return _||xe||(xe=new Promise((r,e)=>{if(typeof window<"u"&&window.ort){_=window.ort,_.env.wasm.wasmPaths=Ae,r(_);return}let t=document.createElement("script");t.src=ot,t.async=!0,t.onload=()=>{window.ort?(_=window.ort,_.env.wasm.wasmPaths=Ae,console.log(`\u2713 ONNX Runtime v${it} loaded from CDN`),r(_)):e(new Error("ONNX Runtime loaded but ort global not found"))},t.onerror=()=>{e(new Error(`Failed to load ONNX Runtime from ${ot}`))},document.head.appendChild(t)}),xe)}async function Ve(){return _||(_=await hs()),_}var le=new Map,He=class{constructor(){h(this,"name","wasm");h(this,"initialized",!1);h(this,"executionProvider","wasm")}get capabilities(){return{concurrency:!0,quantization:!0,float16:this.executionProvider==="webgpu",dynamicShapes:!0,maxBatchSize:32,availableMemory:512*1024*1024}}async isAvailable(){return!0}async initialize(){if(this.initialized)return;let e=await Ve();e.env.wasm.wasmPaths=Ae,this.executionProvider="wasm",this.initialized=!0}async loadModel(e,t={}){this.initialized||await this.initialize();let s=await Ve();try{let n={executionProviders:[this.executionProvider],graphOptimizationLevel:"all"},o=new Uint8Array(e),i=await s.InferenceSession.create(o,n),a=i.inputNames,c=i.outputNames,l=`onnx_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,8)}`;le.set(l,{session:i,inputNames:[...a],outputNames:[...c]});let u={name:t.metadata?.name??"onnx-model",version:"1.0.0",inputs:a.map(d=>({name:d,dtype:"float32",shape:[-1]})),outputs:c.map(d=>({name:d,dtype:"float32",shape:[-1]})),sizeBytes:e.byteLength,quantization:t.quantization??"float32",format:"onnx"},f=new D(u,"wasm",()=>this.unloadModel(l));return Object.defineProperty(f,"id",{value:l,writable:!1}),E().trackModel(f,()=>f.dispose()),f}catch(n){throw new p(`Failed to load ONNX model: ${n instanceof Error?n.message:String(n)}`,m.MODEL_LOAD_FAILED,{error:n})}}async run(e,t){let s=le.get(e.id);if(!s)throw new p(`ONNX session not found for model ${e.id}`,m.MODEL_NOT_LOADED,{modelId:e.id});let n=await Ve(),{session:o,inputNames:i,outputNames:a}=s;try{let c={};for(let f=0;f<Math.min(t.length,i.length);f++){let d=i[f],w=t[f];if(d&&w){let A=w.dtype,x;if(A==="int64"){let y=w.data;x=new n.Tensor("int64",y,w.shape)}else if(A==="int32"){let y=w.data;x=new n.Tensor("int32",y,w.shape)}else{let y=w.toFloat32Array();x=new n.Tensor("float32",y,w.shape)}c[d]=x}}let l=await o.run(c),u=[];for(let f of a){let d=l[f];if(d){let w=d.data,A=Array.from(d.dims).map(x=>Number(x));u.push(new g(new Float32Array(w),A,"float32"))}}return u}catch(c){throw new p(`ONNX inference failed: ${c instanceof Error?c.message:String(c)}`,m.INFERENCE_FAILED,{modelId:e.id,error:c})}}async unloadModel(e){le.get(e)&&le.delete(e)}dispose(){le.clear(),this.initialized=!1}};function at(){return new He}function ct(){re("webgpu",we),re("webnn",ye),re("wasm",at)}ct();var Q=class{constructor(e={}){h(this,"options");h(this,"cache",new Map);h(this,"currentSize",0);h(this,"hits",0);h(this,"misses",0);this.options={strategy:e.strategy??"lru",maxSize:e.maxSize??100*1024*1024,maxEntries:e.maxEntries??1e3,ttl:e.ttl??0,persistent:e.persistent??!1,name:e.name??"edgeflow-cache"},this.options.persistent&&this.loadFromStorage()}get(e){let t=this.cache.get(e);if(!t){this.misses++;return}if(t.ttl&&Date.now()-t.createdAt>t.ttl){this.delete(e),this.misses++;return}return t.accessedAt=Date.now(),t.accessCount++,this.hits++,t.value}set(e,t,s,n){for(this.cache.has(e)&&this.delete(e);(this.currentSize+s>this.options.maxSize||this.cache.size>=this.options.maxEntries)&&this.cache.size>0;)this.evict();let o=n!==void 0?n:this.options.ttl>0?this.options.ttl:void 0,i={value:t,size:s,createdAt:Date.now(),accessedAt:Date.now(),accessCount:1,ttl:o};this.cache.set(e,i),this.currentSize+=s,this.options.persistent&&this.saveToStorage()}has(e){let t=this.cache.get(e);return t?t.ttl&&Date.now()-t.createdAt>t.ttl?(this.delete(e),!1):!0:!1}delete(e){let t=this.cache.get(e);return t?(this.currentSize-=t.size,this.cache.delete(e),this.options.persistent&&this.saveToStorage(),!0):!1}clear(){this.cache.clear(),this.currentSize=0,this.hits=0,this.misses=0,this.options.persistent&&this.clearStorage()}getStats(){let e=this.hits+this.misses;return{entries:this.cache.size,size:this.currentSize,hits:this.hits,misses:this.misses,hitRate:e>0?this.hits/e:0}}evict(){let e=null;switch(this.options.strategy){case"lru":e=this.findLRU();break;case"lfu":e=this.findLFU();break;case"fifo":e=this.findOldest();break;case"ttl":e=this.findExpired()??this.findOldest();break}e&&this.delete(e)}findLRU(){let e=null,t=1/0;for(let[s,n]of this.cache)n.accessedAt<t&&(t=n.accessedAt,e=s);return e}findLFU(){let e=null,t=1/0;for(let[s,n]of this.cache)n.accessCount<t&&(t=n.accessCount,e=s);return e}findOldest(){let e=null,t=1/0;for(let[s,n]of this.cache)n.createdAt<t&&(t=n.createdAt,e=s);return e}findExpired(){let e=Date.now();for(let[t,s]of this.cache)if(s.ttl&&e-s.createdAt>s.ttl)return t;return null}async loadFromStorage(){if(!(typeof indexedDB>"u"))try{let n=(await this.openDB()).transaction("cache","readonly").objectStore("cache").getAll();return new Promise((o,i)=>{n.onsuccess=()=>{let a=n.result;for(let{key:c,entry:l}of a)this.cache.set(c,l),this.currentSize+=l.size;o()},n.onerror=()=>i(n.error)})}catch{}}async saveToStorage(){if(!(typeof indexedDB>"u"))try{let t=(await this.openDB()).transaction("cache","readwrite"),s=t.objectStore("cache");s.clear();for(let[n,o]of this.cache)s.put({key:n,entry:o});return new Promise((n,o)=>{t.oncomplete=()=>n(),t.onerror=()=>o(t.error)})}catch{}}async clearStorage(){if(!(typeof indexedDB>"u"))try{(await this.openDB()).transaction("cache","readwrite").objectStore("cache").clear()}catch{}}openDB(){return new Promise((e,t)=>{let s=indexedDB.open(this.options.name,1);s.onupgradeneeded=()=>{let n=s.result;n.objectStoreNames.contains("cache")||n.createObjectStore("cache",{keyPath:"key"})},s.onsuccess=()=>e(s.result),s.onerror=()=>t(s.error)})}},Te=class extends Q{generateKey(e,t){let s=Array.isArray(t)?t:Array.from(t),n=this.hashArray(s);return`${e}:${n}`}hashArray(e){let t=0,s=e.length>100?e.filter((n,o)=>o%Math.floor(e.length/100)===0):e;for(let n=0;n<s.length;n++){let o=s[n]??0;t=(t<<5)-t+(o*1e3|0),t|=0}return t.toString(36)}},B=class{constructor(e="edgeflow-models"){h(this,"cacheName");h(this,"cache",null);this.cacheName=e}async ensureCache(){if(!this.cache){if(typeof caches>"u")throw new Error("Cache API is not available");this.cache=await caches.open(this.cacheName)}return this.cache}async get(e){try{return await(await this.ensureCache()).match(e)??void 0}catch{return}}async put(e,t){try{await(await this.ensureCache()).put(e,t.clone())}catch{}}async delete(e){try{return await(await this.ensureCache()).delete(e)}catch{return!1}}async clear(){try{await caches.delete(this.cacheName),this.cache=null}catch{}}async keys(){try{return(await(await this.ensureCache()).keys()).map(s=>s.url)}catch{return[]}}};function lt(r="medium",e={}){let t={small:{maxSize:10485760,maxEntries:100},medium:{maxSize:104857600,maxEntries:500},large:{maxSize:524288e3,maxEntries:2e3},custom:{}};return new Q({...t[r],...e})}var N=class{constructor(e){h(this,"model",null);h(this,"config");h(this,"modelCache");h(this,"downloadCache");h(this,"isReady",!1);this.config=e,this.modelCache=new se,this.downloadCache=new B}async initialize(){if(this.isReady&&this.model)return;let e=this.modelCache.get(this.config.model);if(e){this.model=e,this.isReady=!0;return}this.model=await this.loadModelWithCache(this.config.model),this.isReady=!0}async loadModelWithCache(e){let t=await this.downloadCache.get(e);try{let s=await fetch(e);s.ok&&await this.downloadCache.put(e,s.clone())}catch{}return We(e,{runtime:this.config.runtime,quantization:this.config.quantization,cache:this.config.cache})}async run(e,t){await this.initialize();let s=performance.now(),n=await this.preprocess(e),o=await Ge(this.model,n),i=await this.postprocess(o,t);return i&&typeof i=="object"&&"processingTime"in i&&(i.processingTime=performance.now()-s),i}async runBatch(e,t){return await this.initialize(),await Promise.all(e.map(n=>this.run(n,t)))}get task(){return this.config.task}get ready(){return this.isReady}dispose(){this.model&&(this.model.dispose(),this.model=null),this.isReady=!1}},ut=new Map;function L(r,e){ut.set(r,e)}function ht(r){return ut.get(r)}var ue=["negative","positive"],dt=["anger","disgust","fear","joy","sadness","surprise","neutral"],Ie=["tench","goldfish","great white shark","tiger shark","hammerhead","electric ray","stingray","cock","hen","ostrich"];var J=class{constructor(e,t={}){h(this,"vocab");h(this,"reverseVocab");h(this,"config");h(this,"model");h(this,"merges",new Map);this.config={vocabSize:e.vocabSize??30522,maxLength:e.maxLength??512,padTokenId:e.padTokenId??0,unkTokenId:e.unkTokenId??100,bosTokenId:e.bosTokenId,eosTokenId:e.eosTokenId,sepTokenId:e.sepTokenId??102,clsTokenId:e.clsTokenId??101,maskTokenId:e.maskTokenId??103},this.model=t.model??"basic",this.vocab=new Map,this.reverseVocab=new Map,t.vocab&&this.loadVocab(t.vocab),t.merges&&this.loadMerges(t.merges)}loadVocab(e){e instanceof Map?this.vocab=new Map(e):this.vocab=new Map(Object.entries(e));for(let[t,s]of this.vocab)this.reverseVocab.set(s,t)}loadMerges(e){for(let t of e){let[s,n]=t.split(" ");s&&n&&this.merges.set(`${s} ${n}`,`${s}${n}`)}}encode(e,t={}){let{addSpecialTokens:s=!0,maxLength:n=this.config.maxLength,padding:o="max_length",truncation:i=!0,returnAttentionMask:a=!0,returnTokenTypeIds:c=!1}=t,l=this.tokenize(e);s&&(l=this.addSpecialTokens(l));let u=this.convertTokensToIds(l);i&&u.length>n&&(u=u.slice(0,n),s&&this.config.sepTokenId!==void 0&&(u[u.length-1]=this.config.sepTokenId));let f=a?u.map(()=>1):[];if(o==="max_length"&&u.length<n){let w=n-u.length;u=[...u,...new Array(w).fill(this.config.padTokenId)],a&&f.push(...new Array(w).fill(0))}let d={inputIds:u,attentionMask:f};return c&&(d.tokenTypeIds=u.map(()=>0)),d}encodeBatch(e,t={}){let s=t.maxLength??this.config.maxLength;if(t.padding==="longest"){let n=e.map(o=>this.encode(o,{...t,padding:"do_not_pad"}));s=Math.max(...n.map(o=>o.inputIds.length))}return e.map(n=>this.encode(n,{...t,maxLength:s}))}decode(e,t=!0){let s=this.convertIdsToTokens(e),n=t?s.filter(o=>!this.isSpecialToken(o)):s;return this.detokenize(n)}tokenize(e){let t=this.normalize(e);switch(this.model){case"bpe":return this.tokenizeBPE(t);case"wordpiece":return this.tokenizeWordPiece(t);default:return this.tokenizeBasic(t)}}normalize(e){return e.toLowerCase().replace(/[^\w\s'-]/g," $& ").replace(/\s+/g," ").trim()}tokenizeBasic(e){return e.split(/\s+/).filter(t=>t.length>0)}tokenizeWordPiece(e){let t=e.split(/\s+/).filter(n=>n.length>0),s=[];for(let n of t){let o=this.tokenizeWord(n);s.push(...o)}return s}tokenizeWord(e){if(this.vocab.has(e))return[e];let t=[],s=0;for(;s<e.length;){let n=e.length,o=!1;for(;s<n;){let i=s===0?e.slice(s,n):`##${e.slice(s,n)}`;if(this.vocab.has(i)){t.push(i),o=!0;break}n--}o?s=n:(t.push("[UNK]"),s++)}return t}tokenizeBPE(e){let t=e.split(/\s+/).filter(n=>n.length>0),s=[];for(let n of t){let o=n.split("").map((i,a)=>a===n.length-1?i+"</w>":i);for(;o.length>1;){let i=null,a=1/0;for(let f=0;f<o.length-1;f++){let d=`${o[f]} ${o[f+1]}`;if(this.merges.has(d)){let w=Array.from(this.merges.keys()).indexOf(d);w<a&&(a=w,i=[f,d])}}if(!i)break;let[c,l]=i,u=this.merges.get(l);o=[...o.slice(0,c),u,...o.slice(c+2)]}s.push(...o)}return s}addSpecialTokens(e){let t=[];return this.config.clsTokenId!==void 0&&t.push("[CLS]"),t.push(...e),this.config.sepTokenId!==void 0&&t.push("[SEP]"),t}convertTokensToIds(e){return e.map(t=>{let s=this.vocab.get(t);return s!==void 0?s:t==="[CLS]"?this.config.clsTokenId??this.config.unkTokenId:t==="[SEP]"?this.config.sepTokenId??this.config.unkTokenId:t==="[PAD]"?this.config.padTokenId:t==="[MASK]"?this.config.maskTokenId??this.config.unkTokenId:t==="[UNK]"?this.config.unkTokenId:this.config.unkTokenId})}convertIdsToTokens(e){return e.map(t=>{let s=this.reverseVocab.get(t);return s!==void 0?s:t===this.config.clsTokenId?"[CLS]":t===this.config.sepTokenId?"[SEP]":t===this.config.padTokenId?"[PAD]":t===this.config.maskTokenId?"[MASK]":(t===this.config.unkTokenId,"[UNK]")})}isSpecialToken(e){return["[CLS]","[SEP]","[PAD]","[MASK]","[UNK]"].includes(e)}detokenize(e){return e.join(" ").replace(/ ##/g,"").replace(/<\/w>/g," ").trim()}get vocabSize(){return this.vocab.size}getConfig(){return{...this.config}}};function Z(){let r={"[PAD]":0,"[UNK]":1,"[CLS]":2,"[SEP]":3,"[MASK]":4},e=["the","a","an","is","are","was","were","be","been","being","have","has","had","do","does","did","will","would","could","should","may","might","must","shall","can","need","dare","ought","used","i","you","he","she","it","we","they","me","him","her","us","them","my","your","his","its","our","their","mine","yours","hers","ours","theirs","this","that","these","those","what","which","who","whom","whose","and","but","or","nor","for","yet","so","as","if","when","while","not","no","yes","all","any","both","each","every","few","more","most","other","some","such","only","own","same","than","too","very","good","bad","great","new","old","high","low","big","small","long","short","love","like","hate","want","need","think","know","feel","see","hear"],t=5;for(let s of e)r[s]=t++;return new J({vocabSize:t,maxLength:128,padTokenId:0,unkTokenId:1,clsTokenId:2,sepTokenId:3,maskTokenId:4},{vocab:r,model:"basic"})}async function ft(r){let e=await fetch(r);if(!e.ok)throw new p(`Failed to load tokenizer from ${r}`,m.MODEL_NOT_FOUND);let t=await e.json();return new J(t.config??{},{vocab:t.vocab,merges:t.merges,model:t.model})}var F=class extends N{constructor(t,s){super(t);h(this,"tokenizer",null);h(this,"labels");this.labels=s??ue}async initialize(){await super.initialize(),this.tokenizer||(this.tokenizer=Z())}setLabels(t){this.labels=t}async run(t,s){let n=Array.isArray(t),o=n?t:[t];await this.initialize();let i=performance.now(),a=[];for(let l of o){let u=await this.preprocess(l),f=await this.runInference(u),d=await this.postprocess(f,s);a.push(d)}let c=performance.now()-i;for(let l of a)l.processingTime=c/a.length;return n?a:a[0]}async preprocess(t){let s=Array.isArray(t)?t[0]:t,n=this.tokenizer.encode(s,{maxLength:128,padding:"max_length",truncation:!0}),o=new g(new Float32Array(n.inputIds),[1,n.inputIds.length],"float32"),i=new g(new Float32Array(n.attentionMask),[1,n.attentionMask.length],"float32");return[o,i]}async runInference(t){let s=this.labels.length,n=new Float32Array(s),i=(t[0]?.toFloat32Array()??new Float32Array(0)).reduce((a,c)=>a+c,0);for(let a=0;a<s;a++)n[a]=Math.sin(i*(a+1))*2;return[new g(n,[1,s],"float32")]}async postprocess(t,s){let n=t[0];if(!n)return{label:"unknown",score:0};let i=G(n,-1).toFloat32Array(),a=s?.topK??1;(s?.returnAllScores??!1)||a>1;let l=0,u=i[0]??0;for(let d=1;d<i.length;d++)(i[d]??0)>u&&(u=i[d]??0,l=d);return{label:s?.labels?.[l]??this.labels[l]??`class_${l}`,score:u}}},U=class extends F{constructor(e){super(e,ue)}async analyze(e,t){return this.run(e,t)}};function pt(r={}){return new F({task:"text-classification",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization})}function mt(r={}){return new U({task:"sentiment-analysis",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization})}L("text-classification",r=>new F(r));L("sentiment-analysis",r=>new U(r));var q=class extends N{constructor(t,s=768){super(t);h(this,"tokenizer",null);h(this,"embeddingDim");this.embeddingDim=s}async initialize(){await super.initialize(),this.tokenizer||(this.tokenizer=Z())}async run(t,s){let n=Array.isArray(t),o=n?t:[t];await this.initialize();let i=performance.now(),a=[];for(let l of o){let u=await this.preprocess(l),f=await this.runInference(u),d=await this.postprocess(f,s);a.push(d)}let c=performance.now()-i;for(let l of a)l.processingTime=c/a.length;return n?a:a[0]}async preprocess(t){let s=Array.isArray(t)?t[0]:t,n=this.tokenizer.encode(s,{maxLength:128,padding:"max_length",truncation:!0}),o=new g(new Float32Array(n.inputIds),[1,n.inputIds.length],"float32"),i=new g(new Float32Array(n.attentionMask),[1,n.attentionMask.length],"float32");return[o,i]}async runInference(t){let s=t[0]?.shape[1]??128,n=new Float32Array(s*this.embeddingDim),o=t[0]?.toFloat32Array()??new Float32Array(0);for(let i=0;i<s;i++)for(let a=0;a<this.embeddingDim;a++){let c=o[i]??0;n[i*this.embeddingDim+a]=Math.sin(c*(a+1)*.01)*.1}return[new g(n,[1,s,this.embeddingDim],"float32")]}async postprocess(t,s){let n=t[0];if(!n)return{embeddings:[]};let o=s?.pooling??"mean",i=s?.normalize??!0,a;switch(o){case"cls":a=this.extractCLSEmbedding(n);break;case"max":a=this.maxPooling(n);break;case"none":a=n.toArray();break;case"mean":default:a=this.meanPooling(n);break}return i&&(a=this.normalizeVector(a)),s?.outputDim&&s.outputDim<a.length&&(a=a.slice(0,s.outputDim)),{embeddings:a}}extractCLSEmbedding(t){let s=t.toFloat32Array(),n=t.shape[2]??this.embeddingDim;return Array.from(s.slice(0,n))}meanPooling(t){let s=t.toFloat32Array(),n=t.shape[1]??1,o=t.shape[2]??this.embeddingDim,i=new Float32Array(o);for(let a=0;a<n;a++)for(let c=0;c<o;c++)i[c]=(i[c]??0)+(s[a*o+c]??0)/n;return Array.from(i)}maxPooling(t){let s=t.toFloat32Array(),n=t.shape[1]??1,o=t.shape[2]??this.embeddingDim,i=new Array(o).fill(-1/0);for(let a=0;a<n;a++)for(let c=0;c<o;c++){let l=s[a*o+c]??0;l>(i[c]??-1/0)&&(i[c]=l)}return i}normalizeVector(t){let s=0;for(let n of t)s+=n*n;return s=Math.sqrt(s),s===0?t:t.map(n=>n/s)}};function gt(r={}){return new q({task:"feature-extraction",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization})}L("feature-extraction",r=>new q(r));var ds={width:224,height:224,resizeMode:"cover",mean:[.485,.456,.406],std:[.229,.224,.225],grayscale:!1,channelFormat:"CHW",dtype:"float32"},he=class{constructor(e={}){h(this,"options");h(this,"canvas",null);h(this,"ctx",null);this.options={...ds,...e}}ensureCanvas(){if(!this.canvas)if(typeof document<"u")this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d");else throw new Error("ImagePreprocessor requires a browser environment")}async process(e){let t;typeof e=="string"?t=await this.loadFromUrl(e):e instanceof ImageData?t=e:t=this.toImageData(e);let s=this.resize(t);return this.toTensor(s)}async processBatch(e){let t=await Promise.all(e.map(l=>this.process(l))),s=t.length,n=t[0];if(!n)return new g(new Float32Array(0),[0],"float32");let o=n.shape[0]??3,i=n.shape[1]??this.options.height,a=n.shape[2]??this.options.width,c=new Float32Array(s*o*i*a);for(let l=0;l<t.length;l++){let u=t[l];u&&c.set(u.toFloat32Array(),l*o*i*a)}return new g(c,[s,o,i,a],"float32")}async loadFromUrl(e){return new Promise((t,s)=>{let n=new Image;n.crossOrigin="anonymous",n.onload=()=>{t(this.toImageData(n))},n.onerror=()=>{s(new Error(`Failed to load image from ${e}`))},n.src=e})}toImageData(e){this.ensureCanvas();let{width:t,height:s}=e;return this.canvas.width=t,this.canvas.height=s,this.ctx.drawImage(e,0,0),this.ctx.getImageData(0,0,t,s)}resize(e){let{width:t,height:s,resizeMode:n}=this.options;this.ensureCanvas();let o=0,i=0,a=e.width,c=e.height,l=0,u=0,f=t,d=s;if(n==="contain"){let x=Math.min(t/e.width,s/e.height);f=Math.round(e.width*x),d=Math.round(e.height*x),l=Math.round((t-f)/2),u=Math.round((s-d)/2)}else if(n==="cover"){let x=Math.max(t/e.width,s/e.height);a=Math.round(t/x),c=Math.round(s/x),o=Math.round((e.width-a)/2),i=Math.round((e.height-c)/2)}let w=document.createElement("canvas");return w.width=e.width,w.height=e.height,w.getContext("2d").putImageData(e,0,0),this.canvas.width=t,this.canvas.height=s,(n==="contain"||n==="pad")&&(this.ctx.fillStyle="black",this.ctx.fillRect(0,0,t,s)),this.ctx.drawImage(w,o,i,a,c,l,u,f,d),this.ctx.getImageData(0,0,t,s)}toTensor(e){let{width:t,height:s,mean:n,std:o,grayscale:i,channelFormat:a,dtype:c}=this.options,l=i?1:3,u=new Float32Array(l*s*t),f=e.data;for(let w=0;w<s;w++)for(let A=0;A<t;A++){let x=(w*t+A)*4;if(i){let y=(.299*(f[x]??0)+.587*(f[x+1]??0)+.114*(f[x+2]??0))/255,T=w*t+A;u[T]=(y-(n[0]??0))/(o[0]??1)}else if(a==="CHW")for(let y=0;y<3;y++){let S=((f[x+y]??0)/255-(n[y]??0))/(o[y]??1),R=y*s*t+w*t+A;u[R]=S}else for(let y=0;y<3;y++){let S=((f[x+y]??0)/255-(n[y]??0))/(o[y]??1),R=w*t*3+A*3+y;u[R]=S}}let d=a==="CHW"?[l,s,t]:[s,t,l];return new g(u,d,c)}},fs={sampleRate:16e3,nMels:80,nFft:400,hopLength:160,normalize:!0,maxDuration:30},de=class{constructor(e={}){h(this,"options");h(this,"audioContext",null);this.options={...fs,...e}}ensureAudioContext(){if(!this.audioContext)if(typeof AudioContext<"u")this.audioContext=new AudioContext({sampleRate:this.options.sampleRate});else throw new Error("AudioPreprocessor requires Web Audio API support")}async process(e){let t;typeof e=="string"?t=await this.loadFromUrl(e):e instanceof AudioBuffer?t=this.audioBufferToFloat32(e):e instanceof Float32Array?t=e:t=await this.decodeAudioData(e),this.options.normalize&&(t=this.normalizeAudio(t));let s=this.options.maxDuration*this.options.sampleRate;return t.length>s&&(t=t.slice(0,s)),this.computeMelSpectrogram(t)}async loadFromUrl(e){let t=await fetch(e);if(!t.ok)throw new Error(`Failed to load audio from ${e}`);let s=await t.arrayBuffer();return this.decodeAudioData(s)}async decodeAudioData(e){this.ensureAudioContext();let t=await this.audioContext.decodeAudioData(e);return this.audioBufferToFloat32(t)}audioBufferToFloat32(e){let t=e.getChannelData(0);return new Float32Array(t)}normalizeAudio(e){let t=0;for(let s=0;s<e.length;s++){let n=Math.abs(e[s]??0);n>t&&(t=n)}if(t>0){let s=new Float32Array(e.length);for(let n=0;n<e.length;n++)s[n]=(e[n]??0)/t;return s}return e}computeMelSpectrogram(e){let{nMels:t,nFft:s,hopLength:n}=this.options,o=Math.floor((e.length-s)/n)+1;if(o<=0)return new g(new Float32Array(t),[1,t],"float32");let i=new Float32Array(o*t);for(let a=0;a<o;a++){let c=a*n;for(let l=0;l<t;l++){let u=0,f=Math.floor(l/t*(s/2)),d=Math.floor((l+1)/t*(s/2));for(let w=f;w<Math.min(d,s);w++){let A=e[c+w]??0;u+=A*A}i[a*t+l]=Math.log(u+1e-10)}}return new g(i,[o,t],"float32")}dispose(){this.audioContext&&(this.audioContext.close(),this.audioContext=null)}};function wt(r,e={}){let{lowercase:t=!0,removePunctuation:s=!1,normalizeWhitespace:n=!0,maxLength:o}=e,i=r;return t&&(i=i.toLowerCase()),s&&(i=i.replace(/[^\w\s]/g,"")),n&&(i=i.replace(/\s+/g," ").trim()),o&&i.length>o&&(i=i.slice(0,o)),i}function Me(r="imagenet",e={}){let t={imagenet:{width:224,height:224,mean:[.485,.456,.406],std:[.229,.224,.225]},clip:{width:224,height:224,mean:[.48145466,.4578275,.40821073],std:[.26862954,.26130258,.27577711]},vit:{width:224,height:224,mean:[.5,.5,.5],std:[.5,.5,.5]},custom:{}};return new he({...t[r],...e})}function yt(r="whisper",e={}){let t={whisper:{sampleRate:16e3,nMels:80,nFft:400,hopLength:160},wav2vec:{sampleRate:16e3,normalize:!0},custom:{}};return new de({...t[r],...e})}var $=class extends N{constructor(t,s,n=1e3){super(t);h(this,"preprocessor",null);h(this,"labels");h(this,"numClasses");this.labels=s??Ie,this.numClasses=n}async initialize(){await super.initialize(),this.preprocessor||(this.preprocessor=Me("imagenet"))}setLabels(t){this.labels=t,this.numClasses=t.length}async run(t,s){let n=Array.isArray(t),o=n?t:[t];await this.initialize();let i=performance.now(),a=[];for(let l of o){let u=await this.preprocess(l),f=await this.runInference(u),d=await this.postprocess(f,s);a.push(d)}let c=performance.now()-i;for(let l of a)l.processingTime=c/a.length;return n?a:a[0]}async preprocess(t){let s=Array.isArray(t)?t[0]:t,n=await this.preprocessor.process(s);return n.shape.length===3?[n.reshape([1,...n.shape])]:[n]}async runInference(t){let s=new Float32Array(this.numClasses),n=t[0]?.toFloat32Array()??new Float32Array(0),o=0;for(let i=0;i<Math.min(1e3,n.length);i++)o+=n[i]??0;for(let i=0;i<this.numClasses;i++)s[i]=Math.sin(o*(i+1)*.1)*3;return[new g(s,[1,this.numClasses],"float32")]}async postprocess(t,s){let n=t[0];if(!n)return{label:"unknown",score:0};let i=G(n,-1).toFloat32Array();(s?.topK??1)>1||s?.returnAllScores;let c=0,l=i[0]??0;for(let f=1;f<i.length;f++)(i[f]??0)>l&&(l=i[f]??0,c=f);return{label:s?.labels?.[c]??this.labels[c]??`class_${c}`,score:l}}};function xt(r={},e){return new $({task:"image-classification",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization},e)}L("image-classification",r=>new $(r));async function At(r,e){let t={task:r,model:e?.model??"default",runtime:e?.runtime,cache:e?.cache??!0,quantization:e?.quantization},s;switch(r){case"text-classification":s=new F(t,e?.labels);break;case"sentiment-analysis":s=new U(t);break;case"feature-extraction":s=new q(t);break;case"image-classification":s=new $(t,e?.labels);break;default:throw new Error(`Unknown pipeline task: ${r}`)}return await s.initialize(),s}async function ps(r,e){let t=await Promise.all(r.map(n=>At(n,e))),s={};for(let n=0;n<r.length;n++){let o=r[n];s[o]=t[n]}return s}$e();async function ms(r,e){let t=r instanceof ArrayBuffer?r:await Ke(r),s=t.byteLength,n,o=0,i=0;switch(e.method){case"int8":({data:n,layersQuantized:o,layersSkipped:i}=gs(t,e));break;case"uint8":({data:n,layersQuantized:o,layersSkipped:i}=ws(t,e));break;case"float16":({data:n,layersQuantized:o,layersSkipped:i}=ys(t,e));break;case"int4":({data:n,layersQuantized:o,layersSkipped:i}=xs(t,e));break;default:n=t}return{modelData:n,originalSize:s,quantizedSize:n.byteLength,compressionRatio:s/n.byteLength,stats:{layersQuantized:o,layersSkipped:i}}}async function Ke(r){return new ArrayBuffer(0)}function gs(r,e){let t=new Float32Array(r),s=new Int8Array(t.length),n=0;for(let i=0;i<t.length;i++){let a=Math.abs(t[i]??0);a>n&&(n=a)}let o=n/127;for(let i=0;i<t.length;i++)s[i]=Math.round((t[i]??0)/o);return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function ws(r,e){let t=new Float32Array(r),s=new Uint8Array(t.length),n=1/0,o=-1/0;for(let a=0;a<t.length;a++){let c=t[a]??0;c<n&&(n=c),c>o&&(o=c)}let i=(o-n)/255;for(let a=0;a<t.length;a++)s[a]=Math.round(((t[a]??0)-n)/i);return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function ys(r,e){let t=new Float32Array(r),s=new Uint16Array(t.length);for(let n=0;n<t.length;n++)s[n]=As(t[n]??0);return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function xs(r,e){let t=new Float32Array(r),s=new Uint8Array(Math.ceil(t.length/2)),n=0;for(let i=0;i<t.length;i++){let a=Math.abs(t[i]??0);a>n&&(n=a)}let o=n/7;for(let i=0;i<t.length;i+=2){let a=Math.round((t[i]??0)/o)+8,c=Math.round((t[i+1]??0)/o)+8;s[i/2]=(a&15)<<4|c&15}return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function As(r){let e=new Float32Array(1),t=new Int32Array(e.buffer);e[0]=r;let s=t[0]??0,n=s>>16&32768,o=s>>12&2047,i=s>>23&255;return i<103?n:i>142?(n|=31744,n|=(i===255?0:1)&&s&8388607,n):i<113?(o|=2048,n|=(o>>114-i)+(o>>113-i&1),n):(n|=i-112<<10|o>>1,n+=o&1,n)}async function Ts(r,e){let t=r instanceof ArrayBuffer?r:await Ke(r),s=new Float32Array(t),n=s.length,i=[...s.map(Math.abs)].sort((u,f)=>u-f),a=Math.floor(e.sparsity*i.length),c=i[a]??0,l=0;for(let u=0;u<s.length;u++)Math.abs(s[u]??0)<c&&(s[u]=0,l++);return{modelData:s.buffer,actualSparsity:l/n,parametersPruned:l,totalParameters:n}}async function Is(r){let e=r instanceof ArrayBuffer?r.byteLength:r.metadata.sizeBytes,t=Math.floor(e/4);return{totalParameters:t,sizeBytes:e,layers:[],estimatedFlops:t*2,memoryRequirements:{weights:e,activations:e*.1,total:e*1.1}}}async function Ms(r,e={}){let{warmupRuns:t=3,runs:s=10}=e;for(let d=0;d<t;d++)await r();let n=[];for(let d=0;d<s;d++){let w=performance.now();await r(),n.push(performance.now()-w)}let i=n.reduce((d,w)=>d+w,0)/n.length,a=Math.min(...n),c=Math.max(...n),u=n.map(d=>Math.pow(d-i,2)).reduce((d,w)=>d+w,0)/n.length,f=Math.sqrt(u);return{avgTime:i,minTime:a,maxTime:c,stdDev:f,throughput:1e3/i,times:n}}async function Ss(r,e){let t=r instanceof ArrayBuffer?r:await Ke(r);switch(e){case"json":let s=new Float32Array(t);return JSON.stringify(Array.from(s));case"binary":case"onnx":default:return t}}async function ur(){let r=await oe();return Array.from(r.values()).some(e=>e)}async function hr(){let r=await oe();return r.get("webgpu")?"webgpu":r.get("webnn")?"webnn":r.get("wasm")?"wasm":null}async function dr(r){let e=new B;await Promise.all(r.map(async t=>{if(!await e.get(t)){let s=await fetch(t);s.ok&&await e.put(t,s)}}))}var bs="0.1.0";async function fr(){let r=await oe();return{version:bs,runtimes:{webgpu:r.get("webgpu")??!1,webnn:r.get("webnn")??!1,wasm:r.get("wasm")??!1,auto:!0},features:["concurrent-execution","batch-processing","memory-management","model-caching","quantization"]}}export{de as AudioPreprocessor,N as BasePipeline,Q as Cache,dt as EMOTION_LABELS,p as EdgeFlowError,g as EdgeFlowTensor,m as ErrorCodes,q as FeatureExtractionPipeline,Ie as IMAGENET_LABELS,$ as ImageClassificationPipeline,he as ImagePreprocessor,Te as InferenceCache,ee as InferenceScheduler,D as LoadedModelImpl,V as MemoryManager,te as MemoryScope,se as ModelCache,B as ModelDownloadCache,z as RuntimeManager,ue as SENTIMENT_LABELS,U as SentimentAnalysisPipeline,F as TextClassificationPipeline,J as Tokenizer,bs as VERSION,ce as WASMRuntime,ie as WebGPURuntime,ae as WebNNRuntime,Rt as add,Is as analyzeModel,Ct as arange,jt as argmax,Ms as benchmark,Ue as cancelPreload,Re as clearModelCache,Wt as concat,Kt as configureScheduler,yt as createAudioPreprocessor,Z as createBasicTokenizer,lt as createCache,gt as createFeatureExtractionPipeline,xt as createImageClassificationPipeline,Me as createImagePreprocessor,ps as createPipelines,mt as createSentimentAnalysisPipeline,pt as createTextClassificationPipeline,rt as createWASMRuntime,we as createWebGPURuntime,ye as createWebNNRuntime,Fe as deleteCachedModel,Je as div,Ss as exportModel,Ft as eye,Nt as full,es as gc,oe as getAvailableRuntimes,us as getBestRuntime,hr as getBestRuntimeType,Le as getCachedModel,fr as getInfo,E as getMemoryManager,Jt as getMemoryStats,Oe as getModelCacheStats,ht as getPipelineFactory,Be as getPreloadStatus,qe as getPreloadedModel,ls as getRuntimeManager,pe as getScheduler,Ce as isModelCached,ur as isSupported,Lt as linspace,We as loadModel,me as loadModelData,as as loadModelFromBuffer,ft as loadTokenizer,Ut as matmul,$t as mean,Bt as mul,_t as ones,At as pipeline,dr as preload,Pe as preloadModel,ve as preloadModels,wt as preprocessText,Ts as prune,ms as quantize,vt as randn,Pt as random,ct as registerAllBackends,L as registerPipeline,re as registerRuntime,Zt as release,Ee as relu,cs as runBatchInference,Ge as runInference,et as setScheduler,ke as sigmoid,G as softmax,Ot as sub,be as sum,qt as tanh,Dt as tensor,Yt as withMemoryScope,Qt as withMemoryScopeSync,Qe as zeros};
//# sourceMappingURL=edgeflow.browser.min.js.map

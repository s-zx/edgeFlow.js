var lt=Object.defineProperty;var Ht=(r,t,e)=>t in r?lt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var Gt=(r,t)=>()=>(r&&(t=r(r=0)),t);var Vt=(r,t)=>{for(var e in t)lt(r,e,{get:t[e],enumerable:!0})};var h=(r,t,e)=>(Ht(r,typeof t!="symbol"?t+"":t,e),e);var mt={};Vt(mt,{cancelPreload:()=>Ye,clearModelCache:()=>Xe,deleteCachedModel:()=>Ve,getCachedModel:()=>Ge,getModelCacheStats:()=>Qe,getPreloadStatus:()=>Ke,getPreloadedModel:()=>Je,isModelCached:()=>ce,loadModelData:()=>Q,preloadModel:()=>We,preloadModels:()=>He});async function Is(r){try{let t=await fetch(r,{method:"HEAD"}),e=t.headers.get("Accept-Ranges"),s=t.headers.get("Content-Length"),n=t.headers.get("ETag")??void 0;return{supports:e==="bytes",size:s?parseInt(s,10):0,etag:n}}catch{return{supports:!1,size:0}}}async function Ms(r,t,e,s){let n=new AbortController,o=setTimeout(()=>n.abort(),s);try{let i=await fetch(r,{headers:{Range:`bytes=${t}-${e}`},signal:n.signal});if(i.status!==206&&i.status!==200)throw new Error(`HTTP ${i.status}: ${i.statusText}`);return await i.arrayBuffer()}finally{clearTimeout(o)}}async function Ss(r,t){let{chunkSize:e=5*1024*1024,parallelConnections:s=4,timeout:n=3e4,onProgress:o}=t,{supports:i,size:a,etag:c}=await Is(r);if(!i||a<e*2)return pt(r,n,o);let l=await z.getDownloadState(r);if(!l||c&&l.totalSize!==a){let M=Math.ceil(a/e),_=[];for(let D=0;D<M;D++){let Z=D*e,Le=Math.min(Z+e-1,a-1);_.push({index:D,start:Z,end:Le,downloaded:!1})}l={url:r,totalSize:a,downloadedSize:0,chunks:_,startedAt:Date.now()},await z.deleteModel(r)}let u=l.chunks.filter(M=>!M.downloaded),d=l.downloadedSize,p=Date.now(),x=d,T=()=>{if(!o)return;let M=Date.now(),_=(M-p)/1e3,D=d-x,Z=_>0?D/_:0,Le=a-d,jt=Z>0?Le/Z*1e3:0;o({loaded:d,total:a,percent:d/a*100,speed:Z,eta:jt,currentChunk:l.chunks.filter(Wt=>Wt.downloaded).length,totalChunks:l.chunks.length}),p=M,x=d},y=[...u],b=new Map;for(;y.length>0||b.size>0;){for(;y.length>0&&b.size<s;){let M=y.shift(),_=(async()=>{try{let D=await Ms(r,M.start,M.end,n);await z.saveChunk(r,M.index,D),M.downloaded=!0,d+=D.byteLength,l.downloadedSize=d,await z.saveDownloadState(l),T()}finally{b.delete(M.index)}})();b.set(M.index,_)}b.size>0&&await Promise.race(b.values())}let k=await z.getChunks(r),A=new Uint8Array(a),I=0;for(let M of k)A.set(new Uint8Array(M),I),I+=M.byteLength;return await z.saveMeta({url:r,size:a,etag:c,cachedAt:Date.now(),chunks:k.length,complete:!0}),await z.deleteDownloadState(r),A.buffer}async function pt(r,t,e){let s=new AbortController,n=setTimeout(()=>s.abort(),t);try{let o=await fetch(r,{signal:s.signal});if(!o.ok)throw new Error(`HTTP ${o.status}: ${o.statusText}`);let i=o.headers.get("Content-Length"),a=i?parseInt(i,10):0;if(!o.body||!e||a===0)return await o.arrayBuffer();let c=o.body.getReader(),l=[],u=0,d=Date.now();for(;;){let{done:x,value:T}=await c.read();if(x)break;l.push(T),u+=T.length;let y=(Date.now()-d)/1e3,b=y>0?u/y:0,k=a-u,A=b>0?k/b*1e3:0;e({loaded:u,total:a,percent:u/a*100,speed:b,eta:A})}let f=new Uint8Array(u),p=0;for(let x of l)f.set(x,p),p+=x.length;return f.buffer}finally{clearTimeout(n)}}async function Q(r,t={}){let{cache:e=!0,forceDownload:s=!1,resumable:n=!0}=t;if(e&&!s){let i=await z.getModel(r);if(i)return console.log(`\u2713 Model loaded from cache: ${r}`),t.onProgress?.({loaded:i.byteLength,total:i.byteLength,percent:100,speed:0,eta:0}),i}let o;return n?o=await Ss(r,t):o=await pt(r,t.timeout??3e4,t.onProgress),e&&(n||(await z.saveChunk(r,0,o),await z.saveMeta({url:r,size:o.byteLength,cachedAt:Date.now(),chunks:1,complete:!0}))),o}function We(r,t={}){return ae.preload(r,t)}function He(r,t={}){return Promise.all(r.map(({url:e,priority:s})=>ae.preload(e,{...t,priority:s})))}async function ce(r){return(await z.getMeta(r))?.complete??!1}async function Ge(r){return z.getModel(r)}async function Ve(r){return z.deleteModel(r)}async function Xe(){return z.clear()}async function Qe(){return z.getStats()}function Ke(r){return ae.getStatus(r)}function Ye(r){ae.cancel(r)}async function Je(r){return ae.get(r)}var bs,v,O,R,$e,z,je,ae,xe=Gt(()=>{"use strict";bs="edgeflow-model-cache",v="meta",O="chunks",R="download-state",$e=class{constructor(){h(this,"db",null);h(this,"dbPromise",null)}async openDB(){return this.db?this.db:this.dbPromise?this.dbPromise:(this.dbPromise=new Promise((t,e)=>{let s=indexedDB.open(bs,1);s.onupgradeneeded=n=>{let o=n.target.result;o.objectStoreNames.contains(v)||o.createObjectStore(v,{keyPath:"url"}),o.objectStoreNames.contains(O)||o.createObjectStore(O,{keyPath:["url","index"]}).createIndex("url","url",{unique:!1}),o.objectStoreNames.contains(R)||o.createObjectStore(R,{keyPath:"url"})},s.onsuccess=()=>{this.db=s.result,t(this.db)},s.onerror=()=>e(s.error)}),this.dbPromise)}async getMeta(t){let e=await this.openDB();return new Promise((s,n)=>{let a=e.transaction(v,"readonly").objectStore(v).get(t);a.onsuccess=()=>s(a.result??null),a.onerror=()=>n(a.error)})}async saveMeta(t){let e=await this.openDB();return new Promise((s,n)=>{let o=e.transaction(v,"readwrite");o.objectStore(v).put(t),o.oncomplete=()=>s(),o.onerror=()=>n(o.error)})}async saveChunk(t,e,s){let n=await this.openDB();return new Promise((o,i)=>{let a=n.transaction(O,"readwrite");a.objectStore(O).put({url:t,index:e,data:s}),a.oncomplete=()=>o(),a.onerror=()=>i(a.error)})}async getChunks(t){let e=await this.openDB();return new Promise((s,n)=>{let c=e.transaction(O,"readonly").objectStore(O).index("url").getAll(t);c.onsuccess=()=>{let l=c.result;l.sort((u,d)=>u.index-d.index),s(l.map(u=>u.data))},c.onerror=()=>n(c.error)})}async getModel(t){let e=await this.getMeta(t);if(!e||!e.complete)return null;let s=await this.getChunks(t);if(s.length===0)return null;let n=s.reduce((a,c)=>a+c.byteLength,0),o=new Uint8Array(n),i=0;for(let a of s)o.set(new Uint8Array(a),i),i+=a.byteLength;return o.buffer}async saveDownloadState(t){let e=await this.openDB();return new Promise((s,n)=>{let o=e.transaction(R,"readwrite");o.objectStore(R).put(t),o.oncomplete=()=>s(),o.onerror=()=>n(o.error)})}async getDownloadState(t){let e=await this.openDB();return new Promise((s,n)=>{let a=e.transaction(R,"readonly").objectStore(R).get(t);a.onsuccess=()=>s(a.result??null),a.onerror=()=>n(a.error)})}async deleteDownloadState(t){let e=await this.openDB();return new Promise((s,n)=>{let o=e.transaction(R,"readwrite");o.objectStore(R).delete(t),o.oncomplete=()=>s(),o.onerror=()=>n(o.error)})}async deleteModel(t){let e=await this.openDB();await new Promise((n,o)=>{let i=e.transaction(v,"readwrite");i.objectStore(v).delete(t),i.oncomplete=()=>n(),i.onerror=()=>o(i.error)}),(await this.getChunks(t)).length>0&&await new Promise((n,o)=>{let i=e.transaction(O,"readwrite"),l=i.objectStore(O).index("url").openCursor(IDBKeyRange.only(t));l.onsuccess=u=>{let d=u.target.result;d&&(d.delete(),d.continue())},i.oncomplete=()=>n(),i.onerror=()=>o(i.error)}),await this.deleteDownloadState(t)}async clear(){let t=await this.openDB(),e=[v,O,R];for(let s of e)await new Promise((n,o)=>{let i=t.transaction(s,"readwrite");i.objectStore(s).clear(),i.oncomplete=()=>n(),i.onerror=()=>o(i.error)})}async getStats(){let t=await this.openDB();return new Promise((e,s)=>{let i=t.transaction(v,"readonly").objectStore(v).getAll();i.onsuccess=()=>{let a=i.result;e({models:a.filter(c=>c.complete).length,totalSize:a.reduce((c,l)=>c+(l.complete?l.size:0),0)})},i.onerror=()=>s(i.error)})}},z=new $e;je=class{constructor(){h(this,"tasks",new Map);h(this,"queue",[]);h(this,"maxConcurrent",2);h(this,"activeCount",0)}preload(t,e={}){let s=this.tasks.get(t);if(s)return s.promise;let n,o,i=new Promise((l,u)=>{n=l,o=u}),a={url:t,priority:e.priority??0,options:e,promise:i,resolve:n,reject:o,status:"pending"};this.tasks.set(t,a);let c=this.queue.findIndex(l=>{let u=this.tasks.get(l);return u&&u.priority<a.priority});return c===-1?this.queue.push(t):this.queue.splice(c,0,t),this.processQueue(),i}async processQueue(){for(;this.queue.length>0&&this.activeCount<this.maxConcurrent;){let t=this.queue.shift();if(!t)break;let e=this.tasks.get(t);!e||e.status!=="pending"||(this.activeCount++,e.status="loading",this.downloadTask(e).finally(()=>{this.activeCount--,this.processQueue()}))}}async downloadTask(t){try{let e=await Q(t.url,t.options);t.status="complete",t.resolve(e)}catch(e){t.status="error",t.reject(e instanceof Error?e:new Error(String(e)))}}isPreloaded(t){return this.tasks.get(t)?.status==="complete"}getStatus(t){return this.tasks.get(t)?.status??"not_found"}async get(t){let e=this.tasks.get(t);return e&&(e.status==="complete"||e.status==="loading")?e.promise:null}cancel(t){let e=this.tasks.get(t);e&&e.status==="pending"&&(this.tasks.delete(t),this.queue=this.queue.filter(s=>s!==t),e.reject(new Error("Preload cancelled")))}clear(){for(let[,t]of this.tasks)t.status==="pending"&&t.reject(new Error("Preload cleared"));this.tasks.clear(),this.queue=[]}},ae=new je});var g=class extends Error{constructor(e,s,n){super(e);h(this,"code");h(this,"details");this.code=s,this.details=n,this.name="EdgeFlowError"}},w={RUNTIME_NOT_AVAILABLE:"RUNTIME_NOT_AVAILABLE",RUNTIME_INIT_FAILED:"RUNTIME_INIT_FAILED",RUNTIME_NOT_INITIALIZED:"RUNTIME_NOT_INITIALIZED",MODEL_NOT_FOUND:"MODEL_NOT_FOUND",MODEL_LOAD_FAILED:"MODEL_LOAD_FAILED",MODEL_INVALID_FORMAT:"MODEL_INVALID_FORMAT",MODEL_NOT_LOADED:"MODEL_NOT_LOADED",INFERENCE_FAILED:"INFERENCE_FAILED",INFERENCE_TIMEOUT:"INFERENCE_TIMEOUT",INFERENCE_CANCELLED:"INFERENCE_CANCELLED",OUT_OF_MEMORY:"OUT_OF_MEMORY",MEMORY_LEAK_DETECTED:"MEMORY_LEAK_DETECTED",TENSOR_SHAPE_MISMATCH:"TENSOR_SHAPE_MISMATCH",TENSOR_DTYPE_MISMATCH:"TENSOR_DTYPE_MISMATCH",TENSOR_DISPOSED:"TENSOR_DISPOSED",PIPELINE_NOT_SUPPORTED:"PIPELINE_NOT_SUPPORTED",PIPELINE_INPUT_INVALID:"PIPELINE_INPUT_INVALID",INVALID_ARGUMENT:"INVALID_ARGUMENT",NOT_IMPLEMENTED:"NOT_IMPLEMENTED",UNKNOWN_ERROR:"UNKNOWN_ERROR"};var Xt=0;function Qt(){return`tensor_${++Xt}_${Date.now().toString(36)}`}function we(r){switch(r){case"float32":return Float32Array;case"float16":return Float32Array;case"int32":return Int32Array;case"int64":return BigInt64Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;default:throw new g(`Unsupported data type: ${r}`,w.INVALID_ARGUMENT,{dtype:r})}}function V(r){return r.length===0?1:r.reduce((t,e)=>t*e,1)}function Kt(r){for(let t=0;t<r.length;t++){let e=r[t];if(e===void 0||!Number.isInteger(e)||e<0)throw new g(`Invalid shape dimension at index ${t}: ${e}`,w.INVALID_ARGUMENT,{shape:r,index:t,dimension:e})}}var m=class r{constructor(t,e,s="float32"){h(this,"id");h(this,"dtype");h(this,"shape");h(this,"size");h(this,"_data");h(this,"_isDisposed",!1);Kt(e),this.id=Qt(),this.dtype=s,this.shape=Object.freeze([...e]),this.size=V(this.shape);let n=this.size;if(t.length!==n)throw new g(`Data length (${t.length}) does not match shape ${JSON.stringify(e)} (expected ${n})`,w.TENSOR_SHAPE_MISMATCH,{dataLength:t.length,expectedSize:n,shape:e});if(t instanceof Array){let o=we(s);if(this._data=new o(t.length),s==="int64"){let i=this._data;for(let a=0;a<t.length;a++)i[a]=BigInt(Math.round(t[a]??0))}else for(let i=0;i<t.length;i++)this._data[i]=t[i]??0}else this._data=t}get data(){return this.checkDisposed(),this._data}get isDisposed(){return this._isDisposed}checkDisposed(){if(this._isDisposed)throw new g("Cannot access disposed tensor",w.TENSOR_DISPOSED,{tensorId:this.id})}toFloat32Array(){if(this.checkDisposed(),this._data instanceof Float32Array)return this._data;let t=new Float32Array(this.size);for(let e=0;e<this.size;e++)t[e]=Number(this._data[e]??0);return t}toArray(){if(this.checkDisposed(),this.dtype==="int64"){let t=this._data,e=[];for(let s=0;s<t.length;s++)e.push(Number(t[s]));return e}return Array.from(this._data)}clone(){this.checkDisposed();let t=this._data.constructor,e=new t(this._data);return new r(e,this.shape,this.dtype)}dispose(){this._isDisposed||(this._isDisposed=!0,Object.assign(this,{_data:null}))}get(...t){if(this.checkDisposed(),t.length!==this.shape.length)throw new g(`Expected ${this.shape.length} indices, got ${t.length}`,w.INVALID_ARGUMENT,{expectedIndices:this.shape.length,gotIndices:t.length});let e=0,s=1;for(let n=this.shape.length-1;n>=0;n--){let o=t[n]??0,i=this.shape[n]??1;if(o<0||o>=i)throw new g(`Index ${o} out of bounds for dimension ${n} with size ${i}`,w.INVALID_ARGUMENT,{index:o,dimension:n,size:i});e+=o*s,s*=i}return Number(this._data[e]??0)}set(t,...e){if(this.checkDisposed(),e.length!==this.shape.length)throw new g(`Expected ${this.shape.length} indices, got ${e.length}`,w.INVALID_ARGUMENT,{expectedIndices:this.shape.length,gotIndices:e.length});let s=0,n=1;for(let o=this.shape.length-1;o>=0;o--){let i=e[o]??0,a=this.shape[o]??1;if(i<0||i>=a)throw new g(`Index ${i} out of bounds for dimension ${o} with size ${a}`,w.INVALID_ARGUMENT,{index:i,dimension:o,size:a});s+=i*n,n*=a}this._data[s]=t}reshape(t){this.checkDisposed();let e=V(t);if(e!==this.size)throw new g(`Cannot reshape tensor of size ${this.size} to shape ${JSON.stringify(t)} (size ${e})`,w.TENSOR_SHAPE_MISMATCH,{currentSize:this.size,newSize:e,newShape:t});let s=this._data.constructor,n=new s(this._data);return new r(n,t,this.dtype)}transpose(){if(this.checkDisposed(),this.shape.length!==2)throw new g("Transpose is currently only supported for 2D tensors",w.NOT_IMPLEMENTED,{shape:this.shape});let[t,e]=this.shape,s=new Float32Array(this.size);for(let n=0;n<t;n++)for(let o=0;o<e;o++)s[o*t+n]=Number(this._data[n*e+o]??0);return new r(s,[e,t],this.dtype)}toString(){return`Tensor(shape=[${this.shape.join(", ")}], dtype=${this.dtype})`}};function Yt(r,t,e="float32"){if(Array.isArray(r)&&r.length>0&&Array.isArray(r[0])){let n=r.length,o=r[0].length,i=[];for(let a of r){if(a.length!==o)throw new g("Nested arrays must have consistent dimensions",w.INVALID_ARGUMENT);i.push(...a)}return new m(i,t??[n,o],e)}let s=t??[r.length];return new m(r,s,e)}function ut(r,t="float32"){let e=V(r),s=we(t),n=new s(e);return new m(n,r,t)}function Jt(r,t="float32"){let e=V(r),s=we(t),n=new s(e);return n.fill(1),new m(n,r,t)}function Zt(r,t,e="float32"){let s=V(r),n=we(e),o=new n(s);return o.fill(t),new m(o,r,e)}function es(r,t="float32"){let e=V(r),s=new Float32Array(e);for(let n=0;n<e;n++)s[n]=Math.random();return new m(s,r,t)}function ts(r,t="float32"){let e=V(r),s=new Float32Array(e);for(let n=0;n<e;n+=2){let o=Math.random(),i=Math.random(),a=Math.sqrt(-2*Math.log(o)),c=2*Math.PI*i;s[n]=a*Math.cos(c),n+1<e&&(s[n+1]=a*Math.sin(c))}return new m(s,r,t)}function ss(r,t,e=1,s="float32"){t===void 0&&(t=r,r=0);let n=Math.ceil((t-r)/e),o=new Float32Array(n);for(let i=0;i<n;i++)o[i]=r+i*e;return new m(o,[n],s)}function ns(r,t,e=50,s="float32"){let n=new Float32Array(e),o=(t-r)/(e-1);for(let i=0;i<e;i++)n[i]=r+i*o;return new m(n,[e],s)}function os(r,t="float32"){let e=new Float32Array(r*r);for(let s=0;s<r;s++)e[s*r+s]=1;return new m(e,[r,r],t)}function rs(r,t){if(typeof t=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)+t;return new m(o,r.shape,r.dtype)}if(r.size!==t.size)throw new g("Tensor sizes must match for element-wise operations",w.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:t.shape});let e=new Float32Array(r.size),s=r.toFloat32Array(),n=t.toFloat32Array();for(let o=0;o<r.size;o++)e[o]=(s[o]??0)+(n[o]??0);return new m(e,r.shape,r.dtype)}function is(r,t){if(typeof t=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)-t;return new m(o,r.shape,r.dtype)}if(r.size!==t.size)throw new g("Tensor sizes must match for element-wise operations",w.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:t.shape});let e=new Float32Array(r.size),s=r.toFloat32Array(),n=t.toFloat32Array();for(let o=0;o<r.size;o++)e[o]=(s[o]??0)-(n[o]??0);return new m(e,r.shape,r.dtype)}function as(r,t){if(typeof t=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)*t;return new m(o,r.shape,r.dtype)}if(r.size!==t.size)throw new g("Tensor sizes must match for element-wise operations",w.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:t.shape});let e=new Float32Array(r.size),s=r.toFloat32Array(),n=t.toFloat32Array();for(let o=0;o<r.size;o++)e[o]=(s[o]??0)*(n[o]??0);return new m(e,r.shape,r.dtype)}function dt(r,t){if(typeof t=="number"){let o=new Float32Array(r.size),i=r.toFloat32Array();for(let a=0;a<r.size;a++)o[a]=(i[a]??0)/t;return new m(o,r.shape,r.dtype)}if(r.size!==t.size)throw new g("Tensor sizes must match for element-wise operations",w.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:t.shape});let e=new Float32Array(r.size),s=r.toFloat32Array(),n=t.toFloat32Array();for(let o=0;o<r.size;o++)e[o]=(s[o]??0)/(n[o]??0);return new m(e,r.shape,r.dtype)}function cs(r,t){if(r.shape.length!==2||t.shape.length!==2)throw new g("matmul requires 2D tensors",w.INVALID_ARGUMENT,{aShape:r.shape,bShape:t.shape});let[e,s]=r.shape,[n,o]=t.shape;if(s!==n)throw new g(`Matrix dimensions incompatible for multiplication: (${e}x${s}) @ (${n}x${o})`,w.TENSOR_SHAPE_MISMATCH,{aShape:r.shape,bShape:t.shape});let i=new Float32Array(e*o),a=r.toFloat32Array(),c=t.toFloat32Array();for(let l=0;l<e;l++)for(let u=0;u<o;u++){let d=0;for(let f=0;f<s;f++)d+=(a[l*s+f]??0)*(c[f*o+u]??0);i[l*o+u]=d}return new m(i,[e,o],r.dtype)}function E(r,t=-1){let e=r.toFloat32Array(),s=new Float32Array(r.size),n=t<0?r.shape.length+t:t;if(n<0||n>=r.shape.length)throw new g(`Invalid axis ${t} for tensor with ${r.shape.length} dimensions`,w.INVALID_ARGUMENT,{axis:t,shape:r.shape});if(r.shape.length===1){let o=-1/0;for(let a=0;a<r.size;a++)(e[a]??0)>o&&(o=e[a]??0);let i=0;for(let a=0;a<r.size;a++)s[a]=Math.exp((e[a]??0)-o),i+=s[a]??0;for(let a=0;a<r.size;a++)s[a]=(s[a]??0)/i;return new m(s,r.shape,r.dtype)}if(r.shape.length===2&&n===1){let[o,i]=r.shape;for(let a=0;a<o;a++){let c=-1/0;for(let u=0;u<i;u++)(e[a*i+u]??0)>c&&(c=e[a*i+u]??0);let l=0;for(let u=0;u<i;u++)s[a*i+u]=Math.exp((e[a*i+u]??0)-c),l+=s[a*i+u]??0;for(let u=0;u<i;u++)s[a*i+u]=(s[a*i+u]??0)/l}return new m(s,r.shape,r.dtype)}throw new g("Softmax currently only supports 1D tensors or 2D tensors along the last axis",w.NOT_IMPLEMENTED,{shape:r.shape,axis:t})}function Re(r){let t=r.toFloat32Array(),e=new Float32Array(r.size);for(let s=0;s<r.size;s++)e[s]=Math.max(0,t[s]??0);return new m(e,r.shape,r.dtype)}function Be(r){let t=r.toFloat32Array(),e=new Float32Array(r.size);for(let s=0;s<r.size;s++)e[s]=1/(1+Math.exp(-(t[s]??0)));return new m(e,r.shape,r.dtype)}function ls(r){let t=r.toFloat32Array(),e=new Float32Array(r.size);for(let s=0;s<r.size;s++)e[s]=Math.tanh(t[s]??0);return new m(e,r.shape,r.dtype)}function Oe(r,t){let e=r.toFloat32Array();if(t===void 0){let o=0;for(let i=0;i<r.size;i++)o+=e[i]??0;return o}let s=t<0?r.shape.length+t:t;if(s<0||s>=r.shape.length)throw new g(`Invalid axis ${t} for tensor with ${r.shape.length} dimensions`,w.INVALID_ARGUMENT,{axis:t,shape:r.shape});let n=[...r.shape];if(n.splice(s,1),n.length===0){let o=0;for(let i=0;i<r.size;i++)o+=e[i]??0;return o}if(r.shape.length===2){let[o,i]=r.shape;if(s===0){let a=new Float32Array(i);for(let c=0;c<i;c++)for(let l=0;l<o;l++)a[c]=(a[c]??0)+(e[l*i+c]??0);return new m(a,[i],r.dtype)}else{let a=new Float32Array(o);for(let c=0;c<o;c++)for(let l=0;l<i;l++)a[c]=(a[c]??0)+(e[c*i+l]??0);return new m(a,[o],r.dtype)}}throw new g("Sum along axis currently only supports up to 2D tensors",w.NOT_IMPLEMENTED,{shape:r.shape,axis:t})}function us(r,t){if(t===void 0)return Oe(r)/r.size;let e=Oe(r,t);if(typeof e=="number")return e/(r.shape[t]??1);let s=r.shape[t]??1;return dt(e,s)}function ds(r,t){let e=r.toFloat32Array();if(t===void 0){let n=0,o=e[0]??-1/0;for(let i=1;i<r.size;i++)(e[i]??-1/0)>o&&(o=e[i]??-1/0,n=i);return n}let s=t<0?r.shape.length+t:t;if(r.shape.length===2&&s===1){let[n,o]=r.shape,i=new Float32Array(n);for(let a=0;a<n;a++){let c=0,l=e[a*o]??-1/0;for(let u=1;u<o;u++)(e[a*o+u]??-1/0)>l&&(l=e[a*o+u]??-1/0,c=u);i[a]=c}return new m(i,[n],"int32")}throw new g("Argmax along axis currently only supports 2D tensors along the last axis",w.NOT_IMPLEMENTED,{shape:r.shape,axis:t})}function hs(r,t=0){if(r.length===0)throw new g("Cannot concatenate empty array of tensors",w.INVALID_ARGUMENT);if(r.length===1)return r[0]?.clone()??ut([0]);let e=r[0];if(!e)throw new g("First tensor is undefined",w.INVALID_ARGUMENT);let s=t<0?e.shape.length+t:t;for(let i=1;i<r.length;i++){let a=r[i];if(a){if(a.shape.length!==e.shape.length)throw new g("All tensors must have the same number of dimensions",w.TENSOR_SHAPE_MISMATCH);for(let c=0;c<e.shape.length;c++)if(c!==s&&e.shape[c]!==a.shape[c])throw new g(`Shape mismatch at dimension ${c}`,w.TENSOR_SHAPE_MISMATCH)}}let n=[...e.shape],o=0;for(let i of r)i&&(o+=i.shape[s]??0);if(n[s]=o,e.shape.length===1){let i=new Float32Array(o),a=0;for(let c of r)c&&(i.set(c.toFloat32Array(),a),a+=c.size);return new m(i,n,e.dtype)}throw new g("Concatenation currently only supports 1D tensors",w.NOT_IMPLEMENTED)}var Ue=class{constructor(t,e,s,n){h(this,"id");h(this,"modelId");h(this,"priority");h(this,"createdAt");h(this,"_status","pending");h(this,"_startedAt");h(this,"_completedAt");h(this,"_result");h(this,"_error");h(this,"_executor");h(this,"_resolvers",[]);h(this,"_cancelled",!1);this.id=t,this.modelId=e,this.priority=s,this.createdAt=Date.now(),this._executor=n}get status(){return this._status}get startedAt(){return this._startedAt}get completedAt(){return this._completedAt}get result(){return this._result}get error(){return this._error}cancel(){if(this._status==="pending"){this._cancelled=!0,this._status="cancelled",this._completedAt=Date.now();let t=new g("Task was cancelled",w.INFERENCE_CANCELLED,{taskId:this.id});for(let{reject:e}of this._resolvers)e(t);this._resolvers=[]}}wait(){return this._status==="completed"?Promise.resolve(this._result):this._status==="failed"?Promise.reject(this._error):this._status==="cancelled"?Promise.reject(new g("Task was cancelled",w.INFERENCE_CANCELLED,{taskId:this.id})):new Promise((t,e)=>{this._resolvers.push({resolve:t,reject:e})})}async execute(){if(!this._cancelled){this._status="running",this._startedAt=Date.now();try{this._result=await this._executor(),this._status="completed",this._completedAt=Date.now();for(let{resolve:t}of this._resolvers)t(this._result)}catch(t){this._error=t instanceof Error?t:new Error(String(t)),this._status="failed",this._completedAt=Date.now();for(let{reject:e}of this._resolvers)e(this._error)}this._resolvers=[]}}},ht={critical:0,high:1,normal:2,low:3},qe=class{constructor(){h(this,"items",[])}get length(){return this.items.length}isEmpty(){return this.items.length===0}enqueue(t){let e=!1;for(let s=0;s<this.items.length;s++){let n=this.items[s];if(n&&ht[t.priority]<ht[n.priority]){this.items.splice(s,0,t),e=!0;break}}e||this.items.push(t)}dequeue(){return this.items.shift()}peek(){return this.items[0]}remove(t){let e=this.items.findIndex(s=>s.id===t);if(e!==-1){let[s]=this.items.splice(e,1);return s}}getAll(){return[...this.items]}clear(){this.items=[]}};var fs=0;function ps(){return`task_${++fs}_${Date.now().toString(36)}`}var ms={maxConcurrentTasks:4,maxConcurrentPerModel:1,defaultTimeout:3e4,enableBatching:!1,maxBatchSize:32,batchTimeout:50},oe=class{constructor(t={}){h(this,"options");h(this,"queues",new Map);h(this,"runningTasks",new Map);h(this,"allTasks",new Map);h(this,"batchers",new Map);h(this,"listeners",new Map);h(this,"globalRunningCount",0);h(this,"isProcessing",!1);h(this,"disposed",!1);this.options={...ms,...t}}getQueue(t){let e=this.queues.get(t);return e||(e=new qe,this.queues.set(t,e)),e}getRunningSet(t){let e=this.runningTasks.get(t);return e||(e=new Set,this.runningTasks.set(t,e)),e}canStartTask(t){if(this.globalRunningCount>=this.options.maxConcurrentTasks)return!1;let e=this.runningTasks.get(t);return!(e&&e.size>=this.options.maxConcurrentPerModel)}async processQueue(){if(this.isProcessing||this.disposed)return;this.isProcessing=!0;try{let e=[];for(let[s,n]of this.queues)for(;!n.isEmpty()&&this.canStartTask(s);){let o=n.dequeue();o&&o.status==="pending"&&(e.push(o),this.getRunningSet(s).add(o.id),this.globalRunningCount++)}await Promise.all(e.map(async s=>{this.emit("inference:start",{taskId:s.id,modelId:s.modelId});try{await s.execute(),this.emit("inference:complete",{taskId:s.id,modelId:s.modelId,duration:(s.completedAt??0)-(s.startedAt??0)})}catch(n){this.emit("inference:error",{taskId:s.id,modelId:s.modelId,error:n})}finally{let n=this.runningTasks.get(s.modelId);n&&n.delete(s.id),this.globalRunningCount--}}))}finally{this.isProcessing=!1}let t=!1;for(let e of this.queues.values())if(!e.isEmpty()){t=!0;break}t&&setTimeout(()=>this.processQueue(),0)}schedule(t,e,s="normal"){if(this.disposed)throw new g("Scheduler has been disposed",w.RUNTIME_NOT_INITIALIZED);let n=new Ue(ps(),t,s,e);return this.allTasks.set(n.id,n),this.getQueue(t).enqueue(n),this.processQueue(),n}scheduleWithTimeout(t,e,s=this.options.defaultTimeout,n="normal"){let o=()=>new Promise((i,a)=>{let c=setTimeout(()=>{a(new g(`Task timed out after ${s}ms`,w.INFERENCE_TIMEOUT,{timeout:s}))},s);e().then(l=>{clearTimeout(c),i(l)}).catch(l=>{clearTimeout(c),a(l)})});return this.schedule(t,o,n)}async scheduleAll(t){let e=t.map(({modelId:s,executor:n,priority:o})=>this.schedule(s,n,o));return Promise.all(e.map(s=>s.wait()))}getTask(t){return this.allTasks.get(t)}cancelTask(t){let e=this.allTasks.get(t);if(e&&e.status==="pending"){e.cancel();for(let s of this.queues.values())s.remove(t);return!0}return!1}cancelAllForModel(t){let e=this.queues.get(t);if(!e)return 0;let s=0;for(let n of e.getAll())n.status==="pending"&&(n.cancel(),s++);return e.clear(),s}getStats(){let t={totalTasks:this.allTasks.size,pendingTasks:0,runningTasks:0,completedTasks:0,failedTasks:0,cancelledTasks:0,queuedByModel:{}};for(let e of this.allTasks.values())switch(e.status){case"pending":t.pendingTasks++;break;case"running":t.runningTasks++;break;case"completed":t.completedTasks++;break;case"failed":t.failedTasks++;break;case"cancelled":t.cancelledTasks++;break}for(let[e,s]of this.queues)t.queuedByModel[e]=s.length;return t}on(t,e){let s=this.listeners.get(t);s||(s=new Set,this.listeners.set(t,s)),s.add(e)}off(t,e){let s=this.listeners.get(t);s&&s.delete(e)}emit(t,e){let s={type:t,timestamp:Date.now(),data:e},n=this.listeners.get(t);if(n)for(let o of n)try{o(s)}catch(i){console.error("Error in event listener:",i)}}clearHistory(){for(let[t,e]of this.allTasks)(e.status==="completed"||e.status==="failed"||e.status==="cancelled")&&this.allTasks.delete(t)}dispose(){this.disposed=!0;for(let t of this.queues.values()){for(let e of t.getAll())e.cancel();t.clear()}for(let t of this.batchers.values())t.clear();this.queues.clear(),this.runningTasks.clear(),this.allTasks.clear(),this.batchers.clear(),this.listeners.clear()}},ee=null;function ye(){return ee||(ee=new oe),ee}function ft(r){ee&&ee.dispose(),ee=r}function gs(r){ft(new oe(r))}var ws={initialSize:67108864,maxSize:536870912,growthFactor:1.5,autoGC:!0,gcThreshold:.8},P=class P{constructor(t={}){h(this,"config");h(this,"resources",new Map);h(this,"disposers",new Map);h(this,"listeners",new Map);h(this,"allocated",0);h(this,"peak",0);h(this,"gcScheduled",!1);h(this,"disposed",!1);this.config={...ws,...t}}static getInstance(){return P.instance||(P.instance=new P),P.instance}static configure(t){P.instance&&console.warn("MemoryManager already initialized, configuration may not apply"),P.instance=new P(t)}track(t,e){if(this.disposed)return;let s=this.estimateTensorSize(t);this.resources.set(t.id,{id:t.id,type:"tensor",size:s,createdAt:Date.now(),stackTrace:this.captureStackTrace()}),e&&this.disposers.set(t.id,e),this.allocated+=s,this.peak=Math.max(this.peak,this.allocated),this.checkMemoryThreshold()}trackModel(t,e){if(this.disposed)return;let s=t.metadata.sizeBytes;this.resources.set(t.id,{id:t.id,type:"model",size:s,createdAt:Date.now(),stackTrace:this.captureStackTrace()}),e&&this.disposers.set(t.id,e),this.allocated+=s,this.peak=Math.max(this.peak,this.allocated),this.checkMemoryThreshold()}untrack(t){let e=this.resources.get(t);e&&(this.allocated-=e.size,this.resources.delete(t),this.disposers.delete(t))}release(t){let e=typeof t=="string"?t:t.id,s=this.disposers.get(e);if(s)try{s()}catch(n){console.error("Error disposing resource:",n)}this.untrack(e)}estimateTensorSize(t){let e=this.getBytesPerElement(t.dtype);return t.size*e}getBytesPerElement(t){switch(t){case"float32":return 4;case"float16":return 2;case"int32":return 4;case"int64":return 8;case"uint8":case"int8":case"bool":return 1;default:return 4}}captureStackTrace(){if(typeof Error.captureStackTrace=="function"){let t={};return Error.captureStackTrace(t,this.captureStackTrace),t.stack}return new Error().stack}checkMemoryThreshold(){if(!this.config.autoGC)return;let t=this.allocated/this.config.maxSize;t>=this.config.gcThreshold&&!this.gcScheduled&&(this.gcScheduled=!0,this.emit("memory:warning",{allocated:this.allocated,maxSize:this.config.maxSize,usage:t}),setTimeout(()=>{this.gc(),this.gcScheduled=!1},0))}gc(){this.emit("memory:gc",{before:this.allocated});let t=Date.now(),e=[];for(let[s,n]of this.resources)t-n.createdAt>5*60*1e3&&e.push(s);this.emit("memory:gc",{after:this.allocated,potentialCleanup:e.length})}getStats(){let t=0,e=0;for(let s of this.resources.values())s.type==="tensor"?t++:e++;return{allocated:this.allocated,used:this.allocated,peak:this.peak,tensorCount:t,modelCount:e}}getResourceDetails(){return Array.from(this.resources.values())}detectLeaks(t=10*60*1e3){let e=Date.now(),s=[];for(let n of this.resources.values())e-n.createdAt>t&&s.push(n);return s}on(t,e){let s=this.listeners.get(t);s||(s=new Set,this.listeners.set(t,s)),s.add(e)}off(t,e){let s=this.listeners.get(t);s&&s.delete(e)}emit(t,e){let s={type:t,timestamp:Date.now(),data:e},n=this.listeners.get(t);if(n)for(let o of n)try{o(s)}catch(i){console.error("Error in event listener:",i)}}resetStats(){this.peak=this.allocated}disposeAll(){for(let t of this.resources.keys())this.release(t)}dispose(){this.disposeAll(),this.disposed=!0,this.listeners.clear(),P.instance=null}};h(P,"instance",null);var X=P,re=class r{constructor(t){h(this,"resources",[]);h(this,"children",[]);h(this,"parent",null);t&&(this.parent=t,t.children.push(this))}track(t){return this.resources.push(t),t}createChild(){return new r(this)}keep(t){let e=this.resources.indexOf(t);return e!==-1&&this.resources.splice(e,1),t}dispose(){for(let t of this.children)t.dispose();this.children=[];for(let t=this.resources.length-1;t>=0;t--)try{this.resources[t]?.dispose()}catch(e){console.error("Error disposing resource in scope:",e)}if(this.resources=[],this.parent){let t=this.parent.children.indexOf(this);t!==-1&&this.parent.children.splice(t,1),this.parent=null}}};async function ys(r){let t=new re;try{return await r(t)}finally{t.dispose()}}function xs(r){let t=new re;try{return r(t)}finally{t.dispose()}}var ie=class{constructor(t={}){h(this,"maxSize");h(this,"maxModels");h(this,"cache",new Map);h(this,"currentSize",0);this.maxSize=t.maxSize??256*1024*1024,this.maxModels=t.maxModels??5}get(t){let e=this.cache.get(t);if(e)return e.lastAccess=Date.now(),e.model}set(t,e){let s=e.metadata.sizeBytes;for(;(this.currentSize+s>this.maxSize||this.cache.size>=this.maxModels)&&this.cache.size>0;)this.evictLRU();this.cache.set(t,{model:e,size:s,lastAccess:Date.now()}),this.currentSize+=s}delete(t){let e=this.cache.get(t);return e?(e.model.dispose(),this.currentSize-=e.size,this.cache.delete(t),!0):!1}has(t){return this.cache.has(t)}evictLRU(){let t=null,e=1/0;for(let[s,n]of this.cache)n.lastAccess<e&&(e=n.lastAccess,t=s);t&&this.delete(t)}clear(){for(let t of this.cache.values())t.model.dispose();this.cache.clear(),this.currentSize=0}getStats(){return{size:this.currentSize,count:this.cache.size,maxSize:this.maxSize,maxModels:this.maxModels}}};function N(){return X.getInstance()}function Ts(){return X.getInstance().getStats()}function ks(r){X.getInstance().release(r)}function As(){X.getInstance().gc()}var Te=new Map,$=new Map,Ze=["webgpu","webnn","wasm"],K=class K{constructor(){h(this,"listeners",new Map);h(this,"defaultRuntime","auto")}static getInstance(){return K.instance||(K.instance=new K),K.instance}register(t,e){Te.set(t,e)}async getRuntime(t="auto"){if(t==="auto")return this.getBestRuntime();let e=$.get(t);if(e)return e;let s=Te.get(t);if(!s)throw new g(`Runtime '${t}' is not registered`,w.RUNTIME_NOT_AVAILABLE,{runtime:t});if(e=s(),!await e.isAvailable())throw new g(`Runtime '${t}' is not available in this environment`,w.RUNTIME_NOT_AVAILABLE,{runtime:t});try{await e.initialize()}catch(o){throw new g(`Failed to initialize runtime '${t}': ${o instanceof Error?o.message:String(o)}`,w.RUNTIME_INIT_FAILED,{runtime:t,error:o})}return $.set(t,e),this.emit("runtime:ready",{runtime:t}),e}async getBestRuntime(){for(let t of Ze)try{let e=$.get(t);if(e)return e;let s=Te.get(t);if(!s)continue;let n=s();if(await n.isAvailable())return await n.initialize(),$.set(t,n),this.emit("runtime:ready",{runtime:t}),n}catch{continue}throw new g("No runtime available. Please ensure WebGPU, WebNN, or WASM is supported.",w.RUNTIME_NOT_AVAILABLE,{triedRuntimes:Ze})}async detectAvailableRuntimes(){let t=new Map;for(let e of Ze){let s=Te.get(e);if(!s){t.set(e,!1);continue}try{let n=s();t.set(e,await n.isAvailable())}catch{t.set(e,!1)}}return t}async getCapabilities(t){return(await this.getRuntime(t)).capabilities}setDefaultRuntime(t){this.defaultRuntime=t}getDefaultRuntimeType(){return this.defaultRuntime}disposeRuntime(t){let e=$.get(t);e&&(e.dispose(),$.delete(t))}disposeAll(){for(let[t,e]of $)e.dispose(),$.delete(t)}on(t,e){let s=this.listeners.get(t);s||(s=new Set,this.listeners.set(t,s)),s.add(e)}off(t,e){let s=this.listeners.get(t);s&&s.delete(e)}emit(t,e){let s={type:t,timestamp:Date.now(),data:e},n=this.listeners.get(t);if(n)for(let o of n)try{o(s)}catch(i){console.error("Error in event listener:",i)}}};h(K,"instance",null);var F=K,zs=0;function Es(){return`model_${++zs}_${Date.now().toString(36)}`}var C=class{constructor(t,e,s){h(this,"id");h(this,"metadata");h(this,"runtime");h(this,"_isLoaded",!0);h(this,"_dispose");this.id=Es(),this.metadata=t,this.runtime=e,this._dispose=s}get isLoaded(){return this._isLoaded}dispose(){this._isLoaded&&(this._isLoaded=!1,this._dispose(),N().untrack(this.id))}};async function et(r,t={}){let s=await F.getInstance().getRuntime(t.runtime??"auto"),{loadModelData:n}=await Promise.resolve().then(()=>(xe(),mt)),o=await n(r,{cache:t.cache??!0,resumable:t.resumable??!0,chunkSize:t.chunkSize,forceDownload:t.forceDownload,onProgress:t.onProgress?a=>{t.onProgress(a.percent/100)}:void 0});return await s.loadModel(o,t)}async function _s(r,t={}){return(await F.getInstance().getRuntime(t.runtime??"auto")).loadModel(r,t)}async function le(r,t){if(!r.isLoaded)throw new g("Model has been disposed",w.MODEL_NOT_LOADED,{modelId:r.id});let s=await F.getInstance().getRuntime(r.runtime);return ye().schedule(r.id,()=>s.run(r,t)).wait()}async function Ds(r,t){let e=ye(),n=await F.getInstance().getRuntime(r.runtime),o=t.map(i=>e.schedule(r.id,()=>n.run(r,i)));return Promise.all(o.map(i=>i.wait()))}function Ps(){return F.getInstance()}function ue(r,t){F.getInstance().register(r,t)}async function Ns(){return F.getInstance().getBestRuntime()}async function de(){return F.getInstance().detectAvailableRuntimes()}var te={STORAGE:128,COPY_SRC:4,COPY_DST:8,MAP_READ:1},gt={COMPUTE:4},he=class{constructor(){h(this,"name","webgpu");h(this,"adapter",null);h(this,"device",null);h(this,"models",new Map);h(this,"initialized",!1)}get capabilities(){return{concurrency:!0,quantization:!0,float16:!0,dynamicShapes:!1,maxBatchSize:64,availableMemory:this.device?.limits.maxBufferSize??256*1024*1024}}async isAvailable(){if(typeof navigator>"u"||!navigator.gpu)return!1;try{return await navigator.gpu.requestAdapter()!==null}catch{return!1}}async initialize(){if(!this.initialized){if(!navigator.gpu)throw new g("WebGPU is not supported in this browser",w.RUNTIME_NOT_AVAILABLE);if(this.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),!this.adapter)throw new g("Failed to get WebGPU adapter",w.RUNTIME_INIT_FAILED);this.device=await this.adapter.requestDevice({requiredFeatures:[],requiredLimits:{}}),this.device.lost.then(t=>{console.error("WebGPU device was lost:",t.message),this.initialized=!1,this.device=null}),this.initialized=!0}}async loadModel(t,e={}){this.ensureInitialized();let s=this.parseModelData(t),n={shaders:new Map,pipelines:new Map,weights:new Map,bindGroupLayouts:[],config:s};await this.uploadWeights(t,n),await this.createPipelines(n);let o=`webgpu_${Date.now().toString(36)}`;this.models.set(o,n);let i={name:s.name||e.metadata?.name||"unknown",version:s.version,inputs:s.inputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),outputs:s.outputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),sizeBytes:t.byteLength,quantization:e.quantization??"float32",format:"edgeflow"},a=new C(i,"webgpu",()=>this.unloadModel(o));return N().trackModel(a,()=>a.dispose()),a}async run(t,e){return this.ensureInitialized(),this.executeModel(e,t.metadata)}async executeModel(t,e){let s=this.device,n=[];for(let o of e.outputs){let i=o.shape.reduce((u,d)=>u*d,1),a=s.createBuffer({size:i*4,usage:te.STORAGE|te.COPY_SRC}),c=s.createBuffer({size:i*4,usage:te.MAP_READ|te.COPY_DST}),l=new Float32Array(i);if(t.length>0&&t[0]){let u=t[0].toFloat32Array();for(let d=0;d<Math.min(i,u.length);d++)l[d]=u[d]??0}n.push(new m(l,o.shape,"float32")),a.destroy(),c.destroy()}return n}parseModelData(t){try{let e=new TextDecoder,s=e.decode(new Uint8Array(t,0,Math.min(1024,t.byteLength)));if(s.trim().startsWith("{")){let n=s.indexOf(`
---
`);n===-1&&(n=t.byteLength);let o=e.decode(new Uint8Array(t,0,n));return JSON.parse(o)}}catch{}return{name:"unknown",version:"1.0.0",layers:[],inputs:[{name:"input",shape:[-1,768],dtype:"float32"}],outputs:[{name:"output",shape:[-1,768],dtype:"float32"}]}}async uploadWeights(t,e){let n=this.device.createBuffer({size:1024,usage:te.STORAGE|te.COPY_DST});e.weights.set("default",n)}async createPipelines(t){let e=this.device,n=e.createShaderModule({code:`
      @group(0) @binding(0) var<storage, read> input: array<f32>;
      @group(0) @binding(1) var<storage, read_write> output: array<f32>;
      
      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
        let idx = gid.x;
        if (idx < arrayLength(&input)) {
          output[idx] = input[idx];
        }
      }
    `});t.shaders.set("default",n);let o=e.createBindGroupLayout({entries:[{binding:0,visibility:gt.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:gt.COMPUTE,buffer:{type:"storage"}}]});t.bindGroupLayouts.push(o);let i=e.createPipelineLayout({bindGroupLayouts:[o]}),a=e.createComputePipeline({layout:i,compute:{module:n,entryPoint:"main"}});t.pipelines.set("default",a)}unloadModel(t){let e=this.models.get(t);if(e){for(let s of e.weights.values())s.destroy();this.models.delete(t)}}ensureInitialized(){if(!this.initialized||!this.device)throw new g("WebGPU runtime is not initialized",w.RUNTIME_NOT_INITIALIZED)}dispose(){for(let t of this.models.keys())this.unloadModel(t);this.device&&(this.device.destroy(),this.device=null),this.adapter=null,this.initialized=!1}};function ke(){return new he}var fe=class{constructor(){h(this,"name","webnn");h(this,"context",null);h(this,"models",new Map);h(this,"initialized",!1);h(this,"deviceType","default")}get capabilities(){return{concurrency:!0,quantization:!0,float16:!0,dynamicShapes:!1,maxBatchSize:32,availableMemory:256*1024*1024}}async isAvailable(){if(typeof navigator>"u"||!navigator.ml)return!1;try{return await navigator.ml.createContext({deviceType:"default"})!==null}catch{return!1}}async initialize(){if(!this.initialized){if(!navigator.ml)throw new g("WebNN is not supported in this browser",w.RUNTIME_NOT_AVAILABLE);try{this.context=await navigator.ml.createContext({deviceType:"gpu",powerPreference:"high-performance"}),this.deviceType="gpu"}catch{try{this.context=await navigator.ml.createContext({deviceType:"cpu"}),this.deviceType="cpu"}catch(t){throw new g(`Failed to create WebNN context: ${t instanceof Error?t.message:String(t)}`,w.RUNTIME_INIT_FAILED)}}this.initialized=!0}}async loadModel(t,e={}){this.ensureInitialized();let s=this.parseModelConfig(t),n=`webnn_${Date.now().toString(36)}`,o={name:s.name||e.metadata?.name||"unknown",version:s.version||"1.0.0",inputs:s.inputs.map(a=>({name:a.name,dtype:a.dtype,shape:a.shape})),outputs:s.outputs.map(a=>({name:a.name,dtype:a.dtype,shape:a.shape})),sizeBytes:t.byteLength,quantization:e.quantization??"float32",format:"edgeflow"},i=new C(o,"webnn",()=>this.unloadModel(n));return N().trackModel(i,()=>i.dispose()),i}async run(t,e){return this.ensureInitialized(),this.executeModel(e,t.metadata)}async executeModel(t,e){let s=[];for(let n of e.outputs){let o=n.shape.reduce((a,c)=>a*c,1),i=new Float32Array(o);if(t.length>0&&t[0]){let a=t[0].toFloat32Array();for(let c=0;c<Math.min(o,a.length);c++)i[c]=a[c]??0}s.push(new m(i,n.shape,"float32"))}return s}parseModelConfig(t){try{let e=new TextDecoder,s=e.decode(new Uint8Array(t,0,Math.min(1024,t.byteLength)));if(s.trim().startsWith("{")){let n=s.indexOf(`
---
`);n===-1&&(n=t.byteLength);let o=e.decode(new Uint8Array(t,0,n));return JSON.parse(o)}}catch{}return{name:"unknown",version:"1.0.0",inputs:[{name:"input",shape:[-1,768],dtype:"float32"}],outputs:[{name:"output",shape:[-1,768],dtype:"float32"}]}}unloadModel(t){this.models.delete(t)}ensureInitialized(){if(!this.initialized||!this.context)throw new g("WebNN runtime is not initialized",w.RUNTIME_NOT_INITIALIZED)}getDeviceType(){return this.deviceType}dispose(){this.models.clear(),this.context=null,this.initialized=!1}};function Ae(){return new fe}var pe=class{constructor(){h(this,"name","wasm");h(this,"module",null);h(this,"simdSupported",!1);h(this,"models",new Map);h(this,"initialized",!1)}get capabilities(){return{concurrency:!1,quantization:!0,float16:!1,dynamicShapes:!0,maxBatchSize:16,availableMemory:128*1024*1024}}async isAvailable(){if(typeof WebAssembly>"u")return!1;try{let t=new Uint8Array([0,97,115,109,1,0,0,0]);return await WebAssembly.instantiate(t),!0}catch{return!1}}async initialize(){if(this.initialized)return;this.simdSupported=await this.checkSIMDSupport();let t=new WebAssembly.Memory({initial:256,maximum:2048});this.module={memory:t,exports:this.createJSFallback(t)},this.initialized=!0}async checkSIMDSupport(){try{let t=new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,253,12,0,0,0,0,11]);return await WebAssembly.instantiate(t),!0}catch{return!1}}createJSFallback(t){let e=0,s=new Map;return{malloc:n=>{let o=e;return e+=n,s.set(o,n),o},free:n=>{s.delete(n)},matmul_f32:(n,o,i,a,c,l,u)=>{let d=new Float32Array(t.buffer),f=n/4,p=a/4,x=u/4;for(let T=0;T<o;T++)for(let y=0;y<l;y++){let b=0;for(let k=0;k<i;k++)b+=(d[f+T*i+k]??0)*(d[p+k*l+y]??0);d[x+T*l+y]=b}},add_f32:(n,o,i,a)=>{let c=new Float32Array(t.buffer),l=n/4,u=o/4,d=i/4;for(let f=0;f<a;f++)c[d+f]=(c[l+f]??0)+(c[u+f]??0)},mul_f32:(n,o,i,a)=>{let c=new Float32Array(t.buffer),l=n/4,u=o/4,d=i/4;for(let f=0;f<a;f++)c[d+f]=(c[l+f]??0)*(c[u+f]??0)},relu_f32:(n,o,i)=>{let a=new Float32Array(t.buffer),c=n/4,l=o/4;for(let u=0;u<i;u++)a[l+u]=Math.max(0,a[c+u]??0)},sigmoid_f32:(n,o,i)=>{let a=new Float32Array(t.buffer),c=n/4,l=o/4;for(let u=0;u<i;u++)a[l+u]=1/(1+Math.exp(-(a[c+u]??0)))},softmax_f32:(n,o,i)=>{let a=new Float32Array(t.buffer),c=n/4,l=o/4,u=-1/0;for(let f=0;f<i;f++)(a[c+f]??0)>u&&(u=a[c+f]??0);let d=0;for(let f=0;f<i;f++)a[l+f]=Math.exp((a[c+f]??0)-u),d+=a[l+f]??0;for(let f=0;f<i;f++)a[l+f]=(a[l+f]??0)/d}}}async loadModel(t,e={}){this.ensureInitialized();let s=this.parseModelConfig(t),n={weights:new Map,config:s,executionOrder:s.layers.map(c=>c.name)};await this.loadWeights(t,n);let o=`wasm_${Date.now().toString(36)}`;this.models.set(o,n);let i={name:s.name||e.metadata?.name||"unknown",version:s.version||"1.0.0",inputs:s.inputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),outputs:s.outputs.map(c=>({name:c.name,dtype:c.dtype,shape:c.shape})),sizeBytes:t.byteLength,quantization:e.quantization??"float32",format:"edgeflow"},a=new C(i,"wasm",()=>this.unloadModel(o));return N().trackModel(a,()=>a.dispose()),a}async run(t,e){return this.ensureInitialized(),this.executeModel(e,t.metadata)}async executeModel(t,e){let s=[];for(let n of e.outputs){let o=n.shape.reduce((a,c)=>a*c,1),i;if(t.length>0&&t[0]){let a=t[0];if(n.name.includes("logits")||n.name.includes("class"))i=E(a);else if(n.name.includes("relu"))i=Re(a);else if(n.name.includes("sigmoid"))i=Be(a);else{let c=new Float32Array(o),l=a.toFloat32Array();for(let u=0;u<Math.min(o,l.length);u++)c[u]=l[u]??0;i=new m(c,n.shape,"float32")}}else i=new m(new Float32Array(o),n.shape,"float32");s.push(i)}return s}parseModelConfig(t){try{let e=new TextDecoder,s=e.decode(new Uint8Array(t,0,Math.min(2048,t.byteLength)));if(s.trim().startsWith("{")){let n=s.indexOf(`
---
`);if(n===-1)try{return JSON.parse(s)}catch{n=t.byteLength}let o=e.decode(new Uint8Array(t,0,n));return JSON.parse(o)}}catch{}return{name:"unknown",version:"1.0.0",layers:[],inputs:[{name:"input",shape:[-1,768],dtype:"float32"}],outputs:[{name:"output",shape:[-1,768],dtype:"float32"}]}}async loadWeights(t,e){}unloadModel(t){let e=this.models.get(t);if(e&&this.module)for(let s of e.weights.values())this.module.exports.free(s.ptr);this.models.delete(t)}ensureInitialized(){if(!this.initialized||!this.module)throw new g("WASM runtime is not initialized",w.RUNTIME_NOT_INITIALIZED)}hasSIMDSupport(){return this.simdSupported}dispose(){for(let t of this.models.keys())this.unloadModel(t);this.module=null,this.initialized=!1}};function wt(){return new pe}var xt="1.17.0",Ie=`https://cdn.jsdelivr.net/npm/onnxruntime-web@${xt}/dist/`,yt=`${Ie}ort.min.js`,L=null,be=null;async function vs(){return L||be||(be=new Promise((r,t)=>{if(typeof window<"u"&&window.ort){L=window.ort,L.env.wasm.wasmPaths=Ie,r(L);return}let e=document.createElement("script");e.src=yt,e.async=!0,e.onload=()=>{window.ort?(L=window.ort,L.env.wasm.wasmPaths=Ie,console.log(`\u2713 ONNX Runtime v${xt} loaded from CDN`),r(L)):t(new Error("ONNX Runtime loaded but ort global not found"))},e.onerror=()=>{t(new Error(`Failed to load ONNX Runtime from ${yt}`))},document.head.appendChild(e)}),be)}async function tt(){return L||(L=await vs()),L}var me=new Map,st=class{constructor(){h(this,"name","wasm");h(this,"initialized",!1);h(this,"executionProvider","wasm")}get capabilities(){return{concurrency:!0,quantization:!0,float16:this.executionProvider==="webgpu",dynamicShapes:!0,maxBatchSize:32,availableMemory:512*1024*1024}}async isAvailable(){return!0}async initialize(){if(this.initialized)return;let t=await tt();t.env.wasm.wasmPaths=Ie,this.executionProvider="wasm",this.initialized=!0}async loadModel(t,e={}){this.initialized||await this.initialize();let s=await tt();try{let n={executionProviders:[this.executionProvider],graphOptimizationLevel:"all"},o=new Uint8Array(t),i=await s.InferenceSession.create(o,n),a=i.inputNames,c=i.outputNames,l=`onnx_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,8)}`;me.set(l,{session:i,inputNames:[...a],outputNames:[...c]});let u={name:e.metadata?.name??"onnx-model",version:"1.0.0",inputs:a.map(f=>({name:f,dtype:"float32",shape:[-1]})),outputs:c.map(f=>({name:f,dtype:"float32",shape:[-1]})),sizeBytes:t.byteLength,quantization:e.quantization??"float32",format:"onnx"},d=new C(u,"wasm",()=>this.unloadModel(l));return Object.defineProperty(d,"id",{value:l,writable:!1}),N().trackModel(d,()=>d.dispose()),d}catch(n){throw new g(`Failed to load ONNX model: ${n instanceof Error?n.message:String(n)}`,w.MODEL_LOAD_FAILED,{error:n})}}async run(t,e){let s=me.get(t.id);if(!s)throw new g(`ONNX session not found for model ${t.id}`,w.MODEL_NOT_LOADED,{modelId:t.id});let n=await tt(),{session:o,inputNames:i,outputNames:a}=s;try{let c={};for(let d=0;d<Math.min(e.length,i.length);d++){let f=i[d],p=e[d];if(f&&p){let x=p.dtype,T;if(x==="int64"){let y=p.data;T=new n.Tensor("int64",y,p.shape)}else if(x==="int32"){let y=p.data;T=new n.Tensor("int32",y,p.shape)}else{let y=p.toFloat32Array();T=new n.Tensor("float32",y,p.shape)}c[f]=T}}let l=await o.run(c),u=[];for(let d of a){let f=l[d];if(f){let p=f.data,x=Array.from(f.dims).map(T=>Number(T));u.push(new m(new Float32Array(p),x,"float32"))}}return u}catch(c){throw new g(`ONNX inference failed: ${c instanceof Error?c.message:String(c)}`,w.INFERENCE_FAILED,{modelId:t.id,error:c})}}async unloadModel(t){me.get(t)&&me.delete(t)}dispose(){me.clear(),this.initialized=!1}};function Tt(){return new st}function kt(){ue("webgpu",ke),ue("webnn",Ae),ue("wasm",Tt)}kt();var se=class{constructor(t={}){h(this,"options");h(this,"cache",new Map);h(this,"currentSize",0);h(this,"hits",0);h(this,"misses",0);this.options={strategy:t.strategy??"lru",maxSize:t.maxSize??100*1024*1024,maxEntries:t.maxEntries??1e3,ttl:t.ttl??0,persistent:t.persistent??!1,name:t.name??"edgeflow-cache"},this.options.persistent&&this.loadFromStorage()}get(t){let e=this.cache.get(t);if(!e){this.misses++;return}if(e.ttl&&Date.now()-e.createdAt>e.ttl){this.delete(t),this.misses++;return}return e.accessedAt=Date.now(),e.accessCount++,this.hits++,e.value}set(t,e,s,n){for(this.cache.has(t)&&this.delete(t);(this.currentSize+s>this.options.maxSize||this.cache.size>=this.options.maxEntries)&&this.cache.size>0;)this.evict();let o=n!==void 0?n:this.options.ttl>0?this.options.ttl:void 0,i={value:e,size:s,createdAt:Date.now(),accessedAt:Date.now(),accessCount:1,ttl:o};this.cache.set(t,i),this.currentSize+=s,this.options.persistent&&this.saveToStorage()}has(t){let e=this.cache.get(t);return e?e.ttl&&Date.now()-e.createdAt>e.ttl?(this.delete(t),!1):!0:!1}delete(t){let e=this.cache.get(t);return e?(this.currentSize-=e.size,this.cache.delete(t),this.options.persistent&&this.saveToStorage(),!0):!1}clear(){this.cache.clear(),this.currentSize=0,this.hits=0,this.misses=0,this.options.persistent&&this.clearStorage()}getStats(){let t=this.hits+this.misses;return{entries:this.cache.size,size:this.currentSize,hits:this.hits,misses:this.misses,hitRate:t>0?this.hits/t:0}}evict(){let t=null;switch(this.options.strategy){case"lru":t=this.findLRU();break;case"lfu":t=this.findLFU();break;case"fifo":t=this.findOldest();break;case"ttl":t=this.findExpired()??this.findOldest();break}t&&this.delete(t)}findLRU(){let t=null,e=1/0;for(let[s,n]of this.cache)n.accessedAt<e&&(e=n.accessedAt,t=s);return t}findLFU(){let t=null,e=1/0;for(let[s,n]of this.cache)n.accessCount<e&&(e=n.accessCount,t=s);return t}findOldest(){let t=null,e=1/0;for(let[s,n]of this.cache)n.createdAt<e&&(e=n.createdAt,t=s);return t}findExpired(){let t=Date.now();for(let[e,s]of this.cache)if(s.ttl&&t-s.createdAt>s.ttl)return e;return null}async loadFromStorage(){if(!(typeof indexedDB>"u"))try{let n=(await this.openDB()).transaction("cache","readonly").objectStore("cache").getAll();return new Promise((o,i)=>{n.onsuccess=()=>{let a=n.result;for(let{key:c,entry:l}of a)this.cache.set(c,l),this.currentSize+=l.size;o()},n.onerror=()=>i(n.error)})}catch{}}async saveToStorage(){if(!(typeof indexedDB>"u"))try{let e=(await this.openDB()).transaction("cache","readwrite"),s=e.objectStore("cache");s.clear();for(let[n,o]of this.cache)s.put({key:n,entry:o});return new Promise((n,o)=>{e.oncomplete=()=>n(),e.onerror=()=>o(e.error)})}catch{}}async clearStorage(){if(!(typeof indexedDB>"u"))try{(await this.openDB()).transaction("cache","readwrite").objectStore("cache").clear()}catch{}}openDB(){return new Promise((t,e)=>{let s=indexedDB.open(this.options.name,1);s.onupgradeneeded=()=>{let n=s.result;n.objectStoreNames.contains("cache")||n.createObjectStore("cache",{keyPath:"key"})},s.onsuccess=()=>t(s.result),s.onerror=()=>e(s.error)})}},Me=class extends se{generateKey(t,e){let s=Array.isArray(e)?e:Array.from(e),n=this.hashArray(s);return`${t}:${n}`}hashArray(t){let e=0,s=t.length>100?t.filter((n,o)=>o%Math.floor(t.length/100)===0):t;for(let n=0;n<s.length;n++){let o=s[n]??0;e=(e<<5)-e+(o*1e3|0),e|=0}return e.toString(36)}},j=class{constructor(t="edgeflow-models"){h(this,"cacheName");h(this,"cache",null);this.cacheName=t}async ensureCache(){if(!this.cache){if(typeof caches>"u")throw new Error("Cache API is not available");this.cache=await caches.open(this.cacheName)}return this.cache}async get(t){try{return await(await this.ensureCache()).match(t)??void 0}catch{return}}async put(t,e){try{await(await this.ensureCache()).put(t,e.clone())}catch{}}async delete(t){try{return await(await this.ensureCache()).delete(t)}catch{return!1}}async clear(){try{await caches.delete(this.cacheName),this.cache=null}catch{}}async keys(){try{return(await(await this.ensureCache()).keys()).map(s=>s.url)}catch{return[]}}};function At(r="medium",t={}){let e={small:{maxSize:10485760,maxEntries:100},medium:{maxSize:104857600,maxEntries:500},large:{maxSize:524288e3,maxEntries:2e3},custom:{}};return new se({...e[r],...t})}var S=class{constructor(t){h(this,"model",null);h(this,"config");h(this,"modelCache");h(this,"downloadCache");h(this,"isReady",!1);this.config=t,this.modelCache=new ie,this.downloadCache=new j}async initialize(){if(this.isReady&&this.model)return;let t=this.modelCache.get(this.config.model);if(t){this.model=t,this.isReady=!0;return}this.model=await this.loadModelWithCache(this.config.model),this.isReady=!0}async loadModelWithCache(t){let e=await this.downloadCache.get(t);try{let s=await fetch(t);s.ok&&await this.downloadCache.put(t,s.clone())}catch{}return et(t,{runtime:this.config.runtime,quantization:this.config.quantization,cache:this.config.cache})}async run(t,e){await this.initialize();let s=performance.now(),n=await this.preprocess(t),o=await le(this.model,n),i=await this.postprocess(o,e);return i&&typeof i=="object"&&"processingTime"in i&&(i.processingTime=performance.now()-s),i}async runBatch(t,e){return await this.initialize(),await Promise.all(t.map(n=>this.run(n,e)))}get task(){return this.config.task}get ready(){return this.isReady}dispose(){this.model&&(this.model.dispose(),this.model=null),this.isReady=!1}},bt=new Map;function B(r,t){bt.set(r,t)}function It(r){return bt.get(r)}var ge=["negative","positive"],Mt=["anger","disgust","fear","joy","sadness","surprise","neutral"],Se=["tench","goldfish","great white shark","tiger shark","hammerhead","electric ray","stingray","cock","hen","ostrich"];var U=class r{constructor(){h(this,"vocab",new Map);h(this,"reverseVocab",new Map);h(this,"merges",new Map);h(this,"addedTokens",new Map);h(this,"specialTokens",new Set);h(this,"modelType","BPE");h(this,"unkToken","[UNK]");h(this,"continuingSubwordPrefix","##");h(this,"padTokenId",0);h(this,"unkTokenId",0);h(this,"clsTokenId");h(this,"sepTokenId");h(this,"maskTokenId");h(this,"bosTokenId");h(this,"eosTokenId");h(this,"maxLength",512);h(this,"doLowerCase",!1);h(this,"stripAccents",!1);h(this,"postProcessor");h(this,"byteEncoder",new Map);h(this,"byteDecoder",new Map);this.initByteEncoder()}initByteEncoder(){let t=[];for(let n=33;n<=126;n++)t.push(n);for(let n=161;n<=172;n++)t.push(n);for(let n=174;n<=255;n++)t.push(n);let e=[...t],s=0;for(let n=0;n<256;n++)t.includes(n)||(t.push(n),e.push(256+s),s++);for(let n=0;n<t.length;n++){let o=t[n],i=String.fromCharCode(e[n]);this.byteEncoder.set(o,i),this.byteDecoder.set(i,o)}}static async fromJSON(t){let e=new r,s=typeof t=="string"?JSON.parse(t):t;if(s.model){if(e.modelType=s.model.type,s.model.vocab)for(let[n,o]of Object.entries(s.model.vocab))e.vocab.set(n,o),e.reverseVocab.set(o,n);if(s.model.merges)for(let n=0;n<s.model.merges.length;n++)e.merges.set(s.model.merges[n],n);e.unkToken=s.model.unk_token??"[UNK]",e.continuingSubwordPrefix=s.model.continuing_subword_prefix??"##"}if(s.added_tokens)for(let n of s.added_tokens){e.addedTokens.set(n.content,n.id),e.reverseVocab.set(n.id,n.content),n.special&&e.specialTokens.add(n.content);let o=n.content.toLowerCase();o.includes("pad")&&(e.padTokenId=n.id),o.includes("unk")&&(e.unkTokenId=n.id),(o.includes("cls")||o==="[cls]")&&(e.clsTokenId=n.id),(o.includes("sep")||o==="[sep]")&&(e.sepTokenId=n.id),o.includes("mask")&&(e.maskTokenId=n.id),(o.includes("bos")||o==="<s>")&&(e.bosTokenId=n.id),(o.includes("eos")||o==="</s>")&&(e.eosTokenId=n.id)}return s.normalizer&&(e.doLowerCase=s.normalizer.lowercase??!1,e.stripAccents=s.normalizer.strip_accents??!1),s.truncation&&(e.maxLength=s.truncation.max_length),s.post_processor&&(e.postProcessor=s.post_processor),e}static async fromUrl(t){let e=await fetch(t);if(!e.ok)throw new g(`Failed to load tokenizer from ${t}: ${e.status}`,w.MODEL_NOT_FOUND);let s=await e.json();return r.fromJSON(s)}static async fromHuggingFace(t,e){let s=e?.revision??"main",n=`https://huggingface.co/${t}/resolve/${s}/tokenizer.json`;return r.fromUrl(n)}normalize(t){let e=t;return this.doLowerCase&&(e=e.toLowerCase()),this.stripAccents&&(e=e.normalize("NFD").replace(/[\u0300-\u036f]/g,"")),e=e.replace(/\s+/g," ").trim(),e}preTokenize(t){let e=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu;return t.match(e)??[t]}textToBytes(t){let s=new TextEncoder().encode(t);return Array.from(s).map(n=>this.byteEncoder.get(n)??"").join("")}bytesToText(t){let e=new Uint8Array(t.split("").map(n=>this.byteDecoder.get(n)??0));return new TextDecoder("utf-8",{fatal:!1}).decode(e)}getPairs(t){let e=new Set;for(let s=0;s<t.length-1;s++)e.add(`${t[s]} ${t[s+1]}`);return e}bpe(t){if(this.vocab.has(t))return[t];let e=t.split(""),s=this.getPairs(e);if(s.size===0)return[t];for(;;){let n=null,o=1/0;for(let d of s){let f=this.merges.get(d);f!==void 0&&f<o&&(o=f,n=d)}if(n===null)break;let i=n.split(" "),a=i[0],c=i[1];if(!a||!c)break;let l=[],u=0;for(;u<e.length;){let d=e.indexOf(a,u);if(d===-1){l.push(...e.slice(u));break}l.push(...e.slice(u,d)),e[d]===a&&d<e.length-1&&e[d+1]===c?(l.push(a+c),u=d+2):(l.push(e[d]),u=d+1)}if(e=l,e.length===1)break;s=this.getPairs(e)}return e}wordPiece(t){if(this.vocab.has(t))return[t];let e=[],s=0;for(;s<t.length;){let n=t.length,o=null;for(;s<n;){let i=t.slice(s,n);if(s>0&&(i=this.continuingSubwordPrefix+i),this.vocab.has(i)){o=i;break}n--}o===null?(e.push(this.unkToken),s++):(e.push(o),s=n)}return e}tokenizeWord(t){if(this.addedTokens.has(t))return[t];switch(this.modelType){case"BPE":{let e=this.textToBytes(t);return this.bpe(e)}case"WordPiece":return this.wordPiece(t);default:return this.vocab.has(t)?[t]:[this.unkToken]}}tokenize(t){let e=this.normalize(t),s=[],n=e,o=Array.from(this.addedTokens.keys()).sort((i,a)=>a.length-i.length);for(let i of o)if(n.includes(i)){let a=n.split(i),c=[];for(let l=0;l<a.length;l++)a[l]&&c.push(a[l]),l<a.length-1&&s.push(i);n=c.join(" ")}if(n.trim()){let i=this.preTokenize(n);for(let a of i){if(!a)continue;let c=this.tokenizeWord(a);s.push(...c)}}return s}convertTokensToIds(t){return t.map(e=>{let s=this.addedTokens.get(e);if(s!==void 0)return s;let n=this.vocab.get(e);return n!==void 0?n:this.unkTokenId})}convertIdsToTokens(t){return t.map(e=>this.reverseVocab.get(e)??this.unkToken)}postProcess(t,e){if(!this.postProcessor){let i=[],a=[];return this.clsTokenId!==void 0&&(i.push(this.clsTokenId),a.push(0)),i.push(...t),a.push(...t.map(()=>0)),this.sepTokenId!==void 0&&(i.push(this.sepTokenId),a.push(0)),e&&(i.push(...e),a.push(...e.map(()=>1)),this.sepTokenId!==void 0&&(i.push(this.sepTokenId),a.push(1))),{ids:i,typeIds:a}}let s=e?this.postProcessor.pair:this.postProcessor.single;if(!s)return{ids:t,typeIds:t.map(()=>0)};let n=[],o=[];for(let i of s)if("SpecialToken"in i){let a=this.postProcessor.special_tokens?.[i.SpecialToken.id];a&&(n.push(...a.ids),o.push(...a.ids.map(()=>i.SpecialToken.type_id)))}else if("Sequence"in i){let a=i.Sequence.id==="A"?t:e??[];n.push(...a),o.push(...a.map(()=>i.Sequence.type_id))}return{ids:n,typeIds:o}}encode(t,e={}){let{addSpecialTokens:s=!0,maxLength:n=this.maxLength,padding:o="max_length",truncation:i=!0,returnAttentionMask:a=!0,returnTokenTypeIds:c=!1,textPair:l}=e,u=this.tokenize(t),d=this.convertTokensToIds(u),f;if(l){let y=this.tokenize(l);f=this.convertTokensToIds(y)}let p;if(s){let y=this.postProcess(d,f);d=y.ids,c&&(p=y.typeIds)}else f&&(d=[...d,...f],c&&(p=[...d.map(()=>0),...f.map(()=>1)]));i&&d.length>n&&(d=d.slice(0,n),p&&(p=p.slice(0,n)));let x=[];if(a&&(x=d.map(()=>1)),o==="max_length"&&d.length<n){let y=n-d.length;d=[...d,...new Array(y).fill(this.padTokenId)],a&&(x=[...x,...new Array(y).fill(0)]),p&&(p=[...p,...new Array(y).fill(0)])}let T={inputIds:d,attentionMask:x};return c&&p&&(T.tokenTypeIds=p),T}encodeBatch(t,e={}){if(e.padding==="longest"){let s=t.map(o=>this.encode(o,{...e,padding:"do_not_pad"})),n=Math.max(...s.map(o=>o.inputIds.length));return t.map(o=>this.encode(o,{...e,maxLength:n,padding:"max_length"}))}return t.map(s=>this.encode(s,e))}decode(t,e=!0){let s=this.convertIdsToTokens(t);e&&(s=s.filter(o=>!this.specialTokens.has(o)));let n=s.join("");return this.modelType==="BPE"&&(n=this.bytesToText(n)),this.modelType==="WordPiece"&&(n=n.replace(new RegExp(this.continuingSubwordPrefix,"g"),"")),n=n.replace(/\s+/g," ").trim(),n}decodeBatch(t,e=!0){return t.map(s=>this.decode(s,e))}get vocabSize(){return this.vocab.size+this.addedTokens.size}getSpecialTokenIds(){return{padTokenId:this.padTokenId,unkTokenId:this.unkTokenId,clsTokenId:this.clsTokenId,sepTokenId:this.sepTokenId,maskTokenId:this.maskTokenId,bosTokenId:this.bosTokenId,eosTokenId:this.eosTokenId}}getConfig(){return{vocabSize:this.vocabSize,maxLength:this.maxLength,padTokenId:this.padTokenId,unkTokenId:this.unkTokenId,clsTokenId:this.clsTokenId,sepTokenId:this.sepTokenId,maskTokenId:this.maskTokenId,bosTokenId:this.bosTokenId,eosTokenId:this.eosTokenId}}isSpecialToken(t){return this.specialTokens.has(t)}getTokenId(t){return this.addedTokens.get(t)??this.vocab.get(t)}getToken(t){return this.reverseVocab.get(t)}};function ne(){return new U}async function St(r){return U.fromUrl(r)}async function zt(r,t){return U.fromHuggingFace(r,t)}var q=class extends S{constructor(e,s){super(e);h(this,"tokenizer",null);h(this,"labels");this.labels=s??ge}async initialize(){await super.initialize(),this.tokenizer||(this.tokenizer=ne())}setLabels(e){this.labels=e}async run(e,s){let n=Array.isArray(e),o=n?e:[e];await this.initialize();let i=performance.now(),a=[];for(let l of o){let u=await this.preprocess(l),d=await this.runInference(u),f=await this.postprocess(d,s);a.push(f)}let c=performance.now()-i;for(let l of a)l.processingTime=c/a.length;return n?a:a[0]}async preprocess(e){let s=Array.isArray(e)?e[0]:e,n=this.tokenizer.encode(s,{maxLength:128,padding:"max_length",truncation:!0}),o=new m(new Float32Array(n.inputIds),[1,n.inputIds.length],"float32"),i=new m(new Float32Array(n.attentionMask),[1,n.attentionMask.length],"float32");return[o,i]}async runInference(e){let s=this.labels.length,n=new Float32Array(s),i=(e[0]?.toFloat32Array()??new Float32Array(0)).reduce((a,c)=>a+c,0);for(let a=0;a<s;a++)n[a]=Math.sin(i*(a+1))*2;return[new m(n,[1,s],"float32")]}async postprocess(e,s){let n=e[0];if(!n)return{label:"unknown",score:0};let i=E(n,-1).toFloat32Array(),a=s?.topK??1;(s?.returnAllScores??!1)||a>1;let l=0,u=i[0]??0;for(let f=1;f<i.length;f++)(i[f]??0)>u&&(u=i[f]??0,l=f);return{label:s?.labels?.[l]??this.labels[l]??`class_${l}`,score:u}}},W=class extends q{constructor(t){super(t,ge)}async analyze(t,e){return this.run(t,e)}};function Et(r={}){return new q({task:"text-classification",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization})}function _t(r={}){return new W({task:"sentiment-analysis",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization})}B("text-classification",r=>new q(r));B("sentiment-analysis",r=>new W(r));var H=class extends S{constructor(e,s=768){super(e);h(this,"tokenizer",null);h(this,"embeddingDim");this.embeddingDim=s}async initialize(){await super.initialize(),this.tokenizer||(this.tokenizer=ne())}async run(e,s){let n=Array.isArray(e),o=n?e:[e];await this.initialize();let i=performance.now(),a=[];for(let l of o){let u=await this.preprocess(l),d=await this.runInference(u),f=await this.postprocess(d,s);a.push(f)}let c=performance.now()-i;for(let l of a)l.processingTime=c/a.length;return n?a:a[0]}async preprocess(e){let s=Array.isArray(e)?e[0]:e,n=this.tokenizer.encode(s,{maxLength:128,padding:"max_length",truncation:!0}),o=new m(new Float32Array(n.inputIds),[1,n.inputIds.length],"float32"),i=new m(new Float32Array(n.attentionMask),[1,n.attentionMask.length],"float32");return[o,i]}async runInference(e){let s=e[0]?.shape[1]??128,n=new Float32Array(s*this.embeddingDim),o=e[0]?.toFloat32Array()??new Float32Array(0);for(let i=0;i<s;i++)for(let a=0;a<this.embeddingDim;a++){let c=o[i]??0;n[i*this.embeddingDim+a]=Math.sin(c*(a+1)*.01)*.1}return[new m(n,[1,s,this.embeddingDim],"float32")]}async postprocess(e,s){let n=e[0];if(!n)return{embeddings:[]};let o=s?.pooling??"mean",i=s?.normalize??!0,a;switch(o){case"cls":a=this.extractCLSEmbedding(n);break;case"max":a=this.maxPooling(n);break;case"none":a=n.toArray();break;case"mean":default:a=this.meanPooling(n);break}return i&&(a=this.normalizeVector(a)),s?.outputDim&&s.outputDim<a.length&&(a=a.slice(0,s.outputDim)),{embeddings:a}}extractCLSEmbedding(e){let s=e.toFloat32Array(),n=e.shape[2]??this.embeddingDim;return Array.from(s.slice(0,n))}meanPooling(e){let s=e.toFloat32Array(),n=e.shape[1]??1,o=e.shape[2]??this.embeddingDim,i=new Float32Array(o);for(let a=0;a<n;a++)for(let c=0;c<o;c++)i[c]=(i[c]??0)+(s[a*o+c]??0)/n;return Array.from(i)}maxPooling(e){let s=e.toFloat32Array(),n=e.shape[1]??1,o=e.shape[2]??this.embeddingDim,i=new Array(o).fill(-1/0);for(let a=0;a<n;a++)for(let c=0;c<o;c++){let l=s[a*o+c]??0;l>(i[c]??-1/0)&&(i[c]=l)}return i}normalizeVector(e){let s=0;for(let n of e)s+=n*n;return s=Math.sqrt(s),s===0?e:e.map(n=>n/s)}};function Dt(r={}){return new H({task:"feature-extraction",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization})}B("feature-extraction",r=>new H(r));var nt={width:224,height:224,resizeMode:"cover",mean:[.485,.456,.406],std:[.229,.224,.225],rescaleFactor:1/255,grayscale:!1,channelFormat:"CHW",dtype:"float32",doResize:!0,doRescale:!0,doNormalize:!0,doCenterCrop:!1,paddingColor:[0,0,0]},Y=class r{constructor(t={}){h(this,"options");h(this,"canvas",null);h(this,"ctx",null);let e=t.size,s=t.width??e??nt.width,n=t.height??e??nt.height;this.options={...nt,...t,width:s,height:n,size:e??s,cropSize:t.cropSize??t.size??s}}static fromConfig(t){let e={},s=t.size;if(s!==void 0){if(typeof s=="number")e.size=s;else if(typeof s=="object"&&s!==null){let f=s;e.width=f.width??f.shortest_edge,e.height=f.height??f.shortest_edge}}let n=t.crop_size;if(n!==void 0){if(typeof n=="number")e.cropSize=n;else if(typeof n=="object"&&n!==null){let f=n;e.cropSize={width:f.width??224,height:f.height??224}}}let o=t.image_mean;Array.isArray(o)&&(e.mean=o);let i=t.image_std;Array.isArray(i)&&(e.std=i);let a=t.rescale_factor;typeof a=="number"&&(e.rescaleFactor=a);let c=t.do_resize;typeof c=="boolean"&&(e.doResize=c);let l=t.do_rescale;typeof l=="boolean"&&(e.doRescale=l);let u=t.do_normalize;typeof u=="boolean"&&(e.doNormalize=u);let d=t.do_center_crop;return typeof d=="boolean"&&(e.doCenterCrop=d),t.resample!==void 0&&(e.resizeMode="cover"),new r(e)}static async fromUrl(t){let e=await fetch(t);if(!e.ok)throw new Error(`Failed to load preprocessor config from ${t}`);let s=await e.json();return r.fromConfig(s)}static async fromHuggingFace(t,e){let s=e?.revision??"main",n=`https://huggingface.co/${t}/resolve/${s}/preprocessor_config.json`;return r.fromUrl(n)}ensureCanvas(){if(!this.canvas)if(typeof document<"u")this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d");else throw new Error("ImagePreprocessor requires a browser environment")}async process(t){let e;typeof t=="string"?e=await this.loadFromUrl(t):t instanceof Blob||t instanceof File?e=await this.loadFromBlob(t):t instanceof ImageData?e=t:e=this.toImageData(t);let s=e;return this.options.doResize&&(s=this.resize(s)),this.options.doCenterCrop&&(s=this.centerCrop(s)),this.toTensor(s)}async processBatch(t){let e=await Promise.all(t.map(l=>this.process(l))),s=e.length,n=e[0];if(!n)return new m(new Float32Array(0),[0],"float32");let o=n.shape[0]??3,i=n.shape[1]??this.options.height,a=n.shape[2]??this.options.width,c=new Float32Array(s*o*i*a);for(let l=0;l<e.length;l++){let u=e[l];u&&c.set(u.toFloat32Array(),l*o*i*a)}return new m(c,[s,o,i,a],"float32")}async loadFromUrl(t){return new Promise((e,s)=>{let n=new Image;n.crossOrigin="anonymous",n.onload=()=>{e(this.toImageData(n))},n.onerror=()=>{s(new Error(`Failed to load image from ${t}`))},n.src=t})}async loadFromBlob(t){let e=URL.createObjectURL(t);try{return await this.loadFromUrl(e)}finally{URL.revokeObjectURL(e)}}centerCrop(t){let e=this.options.cropSize,s,n;typeof e=="number"?(s=e,n=e):(s=e.width,n=e.height);let o=Math.max(0,Math.floor((t.width-s)/2)),i=Math.max(0,Math.floor((t.height-n)/2));this.ensureCanvas();let a=document.createElement("canvas");return a.width=t.width,a.height=t.height,a.getContext("2d").putImageData(t,0,0),this.canvas.width=s,this.canvas.height=n,this.ctx.drawImage(a,o,i,s,n,0,0,s,n),this.ctx.getImageData(0,0,s,n)}toImageData(t){this.ensureCanvas();let{width:e,height:s}=t;return this.canvas.width=e,this.canvas.height=s,this.ctx.drawImage(t,0,0),this.ctx.getImageData(0,0,e,s)}resize(t){let{width:e,height:s,resizeMode:n}=this.options;this.ensureCanvas();let o=0,i=0,a=t.width,c=t.height,l=0,u=0,d=e,f=s;if(n==="contain"){let T=Math.min(e/t.width,s/t.height);d=Math.round(t.width*T),f=Math.round(t.height*T),l=Math.round((e-d)/2),u=Math.round((s-f)/2)}else if(n==="cover"){let T=Math.max(e/t.width,s/t.height);a=Math.round(e/T),c=Math.round(s/T),o=Math.round((t.width-a)/2),i=Math.round((t.height-c)/2)}let p=document.createElement("canvas");return p.width=t.width,p.height=t.height,p.getContext("2d").putImageData(t,0,0),this.canvas.width=e,this.canvas.height=s,(n==="contain"||n==="pad")&&(this.ctx.fillStyle="black",this.ctx.fillRect(0,0,e,s)),this.ctx.drawImage(p,o,i,a,c,l,u,d,f),this.ctx.getImageData(0,0,e,s)}toTensor(t){let{mean:e,std:s,grayscale:n,channelFormat:o,dtype:i,doRescale:a,rescaleFactor:c,doNormalize:l}=this.options,u=t.height,d=t.width,f=n?1:3,p=new Float32Array(f*u*d),x=t.data;for(let y=0;y<u;y++)for(let b=0;b<d;b++){let k=(y*d+b)*4;if(n){let A=.299*(x[k]??0)+.587*(x[k+1]??0)+.114*(x[k+2]??0);a&&(A*=c),l&&(A=(A-(e[0]??0))/(s[0]??1));let I=y*d+b;p[I]=A}else if(o==="CHW")for(let A=0;A<3;A++){let I=x[k+A]??0;a&&(I*=c),l&&(I=(I-(e[A]??0))/(s[A]??1));let M=A*u*d+y*d+b;p[M]=I}else for(let A=0;A<3;A++){let I=x[k+A]??0;a&&(I*=c),l&&(I=(I-(e[A]??0))/(s[A]??1));let M=y*d*3+b*3+A;p[M]=I}}let T=o==="CHW"?[f,u,d]:[u,d,f];return new m(p,T,i)}getOptions(){return{...this.options}}},Fs={sampleRate:16e3,nMels:80,nFft:400,hopLength:160,normalize:!0,maxDuration:30},J=class r{constructor(t={}){h(this,"options");h(this,"audioContext",null);this.options={...Fs,...t}}static fromConfig(t){let e={},s=t.sampling_rate;typeof s=="number"&&(e.sampleRate=s);let n=t.feature_size;typeof n=="number"&&(e.nMels=n);let o=t.n_fft;typeof o=="number"&&(e.nFft=o);let i=t.hop_length;return typeof i=="number"&&(e.hopLength=i),new r(e)}static async fromHuggingFace(t,e){let s=e?.revision??"main",n=`https://huggingface.co/${t}/resolve/${s}/preprocessor_config.json`,o=await fetch(n);if(!o.ok)throw new Error(`Failed to load audio config from ${n}`);let i=await o.json();return r.fromConfig(i)}ensureAudioContext(){if(!this.audioContext)if(typeof AudioContext<"u")this.audioContext=new AudioContext({sampleRate:this.options.sampleRate});else throw new Error("AudioPreprocessor requires Web Audio API support")}async process(t){let e;typeof t=="string"?e=await this.loadFromUrl(t):t instanceof Blob||t instanceof File?e=await this.loadFromBlob(t):t instanceof AudioBuffer?e=this.audioBufferToFloat32(t):t instanceof Float32Array?e=t:e=await this.decodeAudioData(t),this.options.normalize&&(e=this.normalizeAudio(e));let s=this.options.maxDuration*this.options.sampleRate;return e.length>s&&(e=e.slice(0,s)),this.computeMelSpectrogram(e)}async processRaw(t){let e;typeof t=="string"?e=await this.loadFromUrl(t):t instanceof Blob||t instanceof File?e=await this.loadFromBlob(t):t instanceof AudioBuffer?e=this.audioBufferToFloat32(t):t instanceof Float32Array?e=t:e=await this.decodeAudioData(t),this.options.normalize&&(e=this.normalizeAudio(e));let s=this.options.maxDuration*this.options.sampleRate;return e.length>s&&(e=e.slice(0,s)),new m(e,[1,e.length],"float32")}async loadFromUrl(t){let e=await fetch(t);if(!e.ok)throw new Error(`Failed to load audio from ${t}`);let s=await e.arrayBuffer();return this.decodeAudioData(s)}async loadFromBlob(t){let e=await t.arrayBuffer();return this.decodeAudioData(e)}async decodeAudioData(t){this.ensureAudioContext();let e=await this.audioContext.decodeAudioData(t.slice(0));return this.audioBufferToFloat32(e)}audioBufferToFloat32(t){let e=t.getChannelData(0);return new Float32Array(e)}normalizeAudio(t){let e=0;for(let s=0;s<t.length;s++){let n=Math.abs(t[s]??0);n>e&&(e=n)}if(e>0){let s=new Float32Array(t.length);for(let n=0;n<t.length;n++)s[n]=(t[n]??0)/e;return s}return t}computeMelSpectrogram(t){let{nMels:e,nFft:s,hopLength:n}=this.options,o=Math.floor((t.length-s)/n)+1;if(o<=0)return new m(new Float32Array(e),[1,e],"float32");let i=new Float32Array(o*e);for(let a=0;a<o;a++){let c=a*n;for(let l=0;l<e;l++){let u=0,d=Math.floor(l/e*(s/2)),f=Math.floor((l+1)/e*(s/2));for(let p=d;p<Math.min(f,s);p++){let x=t[c+p]??0;u+=x*x}i[a*e+l]=Math.log(u+1e-10)}}return new m(i,[o,e],"float32")}dispose(){this.audioContext&&(this.audioContext.close(),this.audioContext=null)}};function Pt(r,t={}){let{lowercase:e=!0,removePunctuation:s=!1,normalizeWhitespace:n=!0,maxLength:o}=t,i=r;return e&&(i=i.toLowerCase()),s&&(i=i.replace(/[^\w\s]/g,"")),n&&(i=i.replace(/\s+/g," ").trim()),o&&i.length>o&&(i=i.slice(0,o)),i}function ze(r="imagenet",t={}){let e={imagenet:{width:224,height:224,mean:[.485,.456,.406],std:[.229,.224,.225]},clip:{width:224,height:224,mean:[.48145466,.4578275,.40821073],std:[.26862954,.26130258,.27577711]},vit:{width:224,height:224,mean:[.5,.5,.5],std:[.5,.5,.5]},custom:{}};return new Y({...e[r],...t})}function Nt(r="whisper",t={}){let e={whisper:{sampleRate:16e3,nMels:80,nFft:400,hopLength:160},wav2vec:{sampleRate:16e3,normalize:!0},custom:{}};return new J({...e[r],...t})}var G=class extends S{constructor(e,s,n=1e3){super(e);h(this,"preprocessor",null);h(this,"labels");h(this,"numClasses");this.labels=s??Se,this.numClasses=n}async initialize(){await super.initialize(),this.preprocessor||(this.preprocessor=ze("imagenet"))}setLabels(e){this.labels=e,this.numClasses=e.length}async run(e,s){let n=Array.isArray(e),o=n?e:[e];await this.initialize();let i=performance.now(),a=[];for(let l of o){let u=await this.preprocess(l),d=await this.runInference(u),f=await this.postprocess(d,s);a.push(f)}let c=performance.now()-i;for(let l of a)l.processingTime=c/a.length;return n?a:a[0]}async preprocess(e){let s=Array.isArray(e)?e[0]:e,n=await this.preprocessor.process(s);return n.shape.length===3?[n.reshape([1,...n.shape])]:[n]}async runInference(e){let s=new Float32Array(this.numClasses),n=e[0]?.toFloat32Array()??new Float32Array(0),o=0;for(let i=0;i<Math.min(1e3,n.length);i++)o+=n[i]??0;for(let i=0;i<this.numClasses;i++)s[i]=Math.sin(o*(i+1)*.1)*3;return[new m(s,[1,this.numClasses],"float32")]}async postprocess(e,s){let n=e[0];if(!n)return{label:"unknown",score:0};let i=E(n,-1).toFloat32Array();(s?.topK??1)>1||s?.returnAllScores;let c=0,l=i[0]??0;for(let d=1;d<i.length;d++)(i[d]??0)>l&&(l=i[d]??0,c=d);return{label:s?.labels?.[c]??this.labels[c]??`class_${c}`,score:l}}};function vt(r={},t){return new G({task:"image-classification",model:r.model??"default",runtime:r.runtime,cache:r.cache??!0,quantization:r.quantization},t)}B("image-classification",r=>new G(r));var Ee=class extends S{constructor(e){super(e??{task:"text-generation",model:"default"});h(this,"tokenizer",null);h(this,"eosTokenId",50256)}setTokenizer(e){this.tokenizer=e;let s=e.getSpecialTokenIds();this.eosTokenId=s.eosTokenId??s.sepTokenId??50256}async preprocess(e){let s=Array.isArray(e)?e[0]??"":e;if(!this.tokenizer)return[new m(new Float32Array([0]),[1],"float32")];let n=this.tokenizer.encode(s,{addSpecialTokens:!1,padding:"do_not_pad"});return[new m(BigInt64Array.from(n.inputIds.map(o=>BigInt(o))),[1,n.inputIds.length],"int64")]}async postprocess(e,s){return{generatedText:"",tokenIds:[],numTokens:0,processingTime:0}}async run(e,s){await this.initialize();let n=Array.isArray(e)?e:[e],o=await Promise.all(n.map(i=>this.generateSingle(i,s??{})));return Array.isArray(e)?o:o[0]}async*stream(e,s={}){let n=performance.now();if(!this.tokenizer)throw new Error("Tokenizer not set. Call setTokenizer() first.");let{maxNewTokens:o=50,maxLength:i=512,temperature:a=1,topK:c=0,topP:l=1,repetitionPenalty:u=1,stopSequences:d=[],doSample:f=!0}=s,x=[...this.tokenizer.encode(e,{addSpecialTokens:!1,padding:"do_not_pad",truncation:!1}).inputIds],T=[],y="";for(let k=0;k<o&&!(x.length>=i);k++){let A=await this.generateNextToken(x,a,c,l,u,f);if(A===this.eosTokenId){yield{token:"",tokenId:A,generatedText:y,done:!0};break}let I=this.tokenizer.decode([A],!0);T.push(A),x.push(A),y+=I,s.onToken&&s.onToken(I,A);let M=!1;for(let _ of d)if(y.endsWith(_)){y=y.slice(0,-_.length),M=!0;break}if(yield{token:I,tokenId:A,generatedText:y,done:M},M)break}let b=performance.now();console.log(`Generation completed in ${(b-n).toFixed(2)}ms`)}async generateSingle(e,s){let n=performance.now();if(!this.tokenizer)throw new Error("Tokenizer not set. Call setTokenizer() first.");let{maxNewTokens:o=50,maxLength:i=512,temperature:a=1,topK:c=0,topP:l=1,repetitionPenalty:u=1,stopSequences:d=[],doSample:f=!0,returnFullText:p=!1}=s,T=[...this.tokenizer.encode(e,{addSpecialTokens:!1,padding:"do_not_pad",truncation:!1}).inputIds],y=[];for(let A=0;A<o&&!(T.length>=i);A++){let I=await this.generateNextToken(T,a,c,l,u,f);if(I===this.eosTokenId)break;if(y.push(I),T.push(I),s.onToken){let D=this.tokenizer.decode([I],!0);s.onToken(D,I)}let M=this.tokenizer.decode(y,!0),_=!1;for(let D of d)if(M.endsWith(D)){_=!0;break}if(_)break}let b=this.tokenizer.decode(y,!0),k=performance.now();return{generatedText:b,fullText:p?e+b:void 0,tokenIds:y,numTokens:y.length,processingTime:k-n}}async generateNextToken(e,s,n,o,i,a){if(!this.model)throw new Error("Model not loaded");let c=new m(BigInt64Array.from(e.map(k=>BigInt(k))),[1,e.length],"int64"),l=new m(BigInt64Array.from(e.map(()=>BigInt(1))),[1,e.length],"int64"),u=await le(this.model,[c,l]);if(!u||u.length===0)throw new Error("Model returned no outputs");let d=u[0],f=d.toFloat32Array(),p=d.shape[d.shape.length-1]??50257,x=new Float32Array(p),T=(e.length-1)*p;for(let k=0;k<p;k++)x[k]=f[T+k]??0;if(i!==1){for(let k of e)if(k<p){let A=x[k]??0;x[k]=A>0?A/i:A*i}}if(s!==1)for(let k=0;k<p;k++)x[k]=(x[k]??0)/s;let y=new m(x,[p],"float32"),b=E(y).toFloat32Array();return a?this.sample(b,n,o):this.greedy(b)}greedy(e){let s=0,n=e[0]??0;for(let o=1;o<e.length;o++)(e[o]??0)>n&&(n=e[o]??0,s=o);return s}sample(e,s,n){let o=Array.from({length:e.length},(u,d)=>d);o.sort((u,d)=>(e[d]??0)-(e[u]??0));let i=o;if(s>0&&s<e.length&&(i=o.slice(0,s)),n<1){let u=0,d=[];for(let f of i)if(d.push(f),u+=e[f]??0,u>=n)break;i=d}let a=0;for(let u of i)a+=e[u]??0;let c=Math.random()*a,l=0;for(let u of i)if(l+=e[u]??0,l>=c)return u;return i[0]??0}};var Cs=["person","bicycle","car","motorcycle","airplane","bus","train","truck","boat","traffic light","fire hydrant","stop sign","parking meter","bench","bird","cat","dog","horse","sheep","cow","elephant","bear","zebra","giraffe","backpack","umbrella","handbag","tie","suitcase","frisbee","skis","snowboard","sports ball","kite","baseball bat","baseball glove","skateboard","surfboard","tennis racket","bottle","wine glass","cup","fork","knife","spoon","bowl","banana","apple","sandwich","orange","broccoli","carrot","hot dog","pizza","donut","cake","chair","couch","potted plant","bed","dining table","toilet","tv","laptop","mouse","remote","keyboard","cell phone","microwave","oven","toaster","sink","refrigerator","book","clock","vase","scissors","teddy bear","hair drier","toothbrush"],_e=class extends S{constructor(e,s){super(e??{task:"object-detection",model:"default"});h(this,"preprocessor");h(this,"labels");this.labels=s??Cs,this.preprocessor=new Y({width:640,height:640,mean:[.485,.456,.406],std:[.229,.224,.225],channelFormat:"CHW"})}setLabels(e){this.labels=e}async preprocess(e){let s=Array.isArray(e)?e:[e];if(s.length===1){let n=await this.preprocessor.process(s[0]);return[new m(n.toFloat32Array(),[1,...n.shape],"float32")]}return[await this.preprocessor.processBatch(s)]}async postprocess(e,s){let n=s??{},o=n.threshold??.5,i=n.topK??100,a=n.nms??!0,c=n.iouThreshold??.5;if(!e[0])return[];let l=e[0].toFloat32Array(),u=[...e[0].shape],d=this.parseDetections(l,u,o),f=a?this.nonMaxSuppression(d,c):d;return f.sort((p,x)=>x.score-p.score),f=f.slice(0,i),f}parseDetections(e,s,n){let o=[],i=s[1]??0,a=s[2]??0;if(a>=5){let c=a-5;for(let l=0;l<i;l++){let u=l*a,d=e[u+4]??0;if(d<n)continue;let f=0,p=0;for(let A=0;A<c;A++){let I=e[u+5+A]??0;I>f&&(f=I,p=A)}let x=d*f;if(x<n)continue;let T=e[u]??0,y=e[u+1]??0,b=e[u+2]??0,k=e[u+3]??0;o.push({label:this.labels[p]??`class_${p}`,score:x,classId:p,box:{x:Math.max(0,T-b/2),y:Math.max(0,y-k/2),width:b,height:k},boxNormalized:{x:Math.max(0,T-b/2),y:Math.max(0,y-k/2),width:b,height:k}})}}else if(a===4)for(let c=0;c<i;c++){let l=c*a,u=e[l]??0,d=e[l+1]??0,f=e[l+2]??0,p=e[l+3]??0;o.push({label:this.labels[0]??"object",score:1,classId:0,box:{x:u,y:d,width:f-u,height:p-d},boxNormalized:{x:u,y:d,width:f-u,height:p-d}})}return o}nonMaxSuppression(e,s){if(e.length===0)return[];let n=[...e].sort((a,c)=>c.score-a.score),o=[],i=new Array(n.length).fill(!0);for(let a=0;a<n.length;a++){if(!i[a])continue;let c=n[a];o.push(c);for(let l=a+1;l<n.length;l++){if(!i[l])continue;let u=n[l];if(c.classId!==u.classId)continue;this.computeIoU(c.box,u.box)>s&&(i[l]=!1)}}return o}computeIoU(e,s){let n=Math.max(0,Math.min(e.x+e.width,s.x+s.width)-Math.max(e.x,s.x)),o=Math.max(0,Math.min(e.y+e.height,s.y+s.height)-Math.max(e.y,s.y)),i=n*o,a=e.width*e.height,c=s.width*s.height,l=a+c-i;return l>0?i/l:0}};var De=class extends S{constructor(e){super(e??{task:"automatic-speech-recognition",model:"default"});h(this,"audioPreprocessor");h(this,"tokenizer",null);this.audioPreprocessor=new J({sampleRate:16e3,nMels:80,nFft:400,hopLength:160,maxDuration:30})}setTokenizer(e){this.tokenizer=e}async preprocess(e){let s=Array.isArray(e)?e:[e],n=await Promise.all(s.map(o=>this.audioPreprocessor.process(o)));if(n.length===1){let o=n[0];return[new m(o.toFloat32Array(),[1,...o.shape],"float32")]}return n}async postprocess(e,s){let o=(s??{}).returnTimestamps??!1;if(!e[0])return{text:""};let i=e[0].toFloat32Array(),a=e[0].shape,c=this.decodeOutput(i,a),l={text:c};return o&&(l.chunks=this.extractTimestamps(i,a,c)),l}decodeOutput(e,s){let n=s[1]??e.length,o=s[2]??1,i=[];if(o>1)for(let a=0;a<n;a++){let c=a*o,l=0,u=e[c]??-1/0;for(let d=1;d<o;d++)(e[c+d]??-1/0)>u&&(u=e[c+d]??-1/0,l=d);i.push(l)}else for(let a=0;a<e.length;a++)i.push(Math.round(e[a]??0));return this.tokenizer?this.tokenizer.decode(i,!0):i.join(" ")}extractTimestamps(e,s,n){let o=n.split(/\s+/).filter(u=>u.length>0),i=[],a=2.5,c="",l=0;for(let u=0;u<o.length;u++)if(c+=(c?" ":"")+o[u],(u+1)%5===0||u===o.length-1){let d=c.split(/\s+/).length/a;i.push({text:c,start:l,end:l+d}),l=l+d,c=""}return i}async processLongAudio(e,s={}){let n=s.chunkDuration??30,o=s.chunkOverlap??5,a=(await this.audioPreprocessor.processRaw(e)).toFloat32Array(),c=16e3,l=n*c,u=o*c,d=l-u,f=[];for(let T=0;T<a.length;T+=d){let y=Math.min(T+l,a.length),b=a.slice(T,y),k=await this.run(new Float32Array(b),s);if(k.chunks){let A=T/c;k.chunks=k.chunks.map(I=>({...I,start:I.start+A,end:I.end+A}))}f.push(k)}let p=f.map(T=>T.text).join(" "),x=f.flatMap(T=>T.chunks??[]);return{text:p,chunks:x}}};var Pe=class extends S{constructor(e){super(e??{task:"zero-shot-classification",model:"default"});h(this,"tokenizer",null);h(this,"hypothesisTemplate","This text is about {label}.")}setTokenizer(e){this.tokenizer=e}async classify(e,s,n){return this.run({text:e,candidateLabels:s},n)}async run(e,s){await this.initialize();let{text:n,candidateLabels:o}=e,i=s??{},a=Array.isArray(n)?n:[n],c=i.hypothesisTemplate??this.hypothesisTemplate,l=i.multiLabel??!1,u=await Promise.all(a.map(d=>this.classifySingle(d,o,c,l)));return Array.isArray(n)?u:u[0]}async classifySingle(e,s,n,o){let i=performance.now(),a=s.map(d=>n.replace("{label}",d)),c=[];for(let d of a){let f=await this.scoreHypothesis(e,d);c.push(f)}let l;if(o)l=c.map(d=>1/(1+Math.exp(-d)));else{let d=new m(new Float32Array(c),[c.length],"float32");l=Array.from(E(d).toFloat32Array())}let u=s.map((d,f)=>({label:d,score:l[f]??0}));return u.sort((d,f)=>f.score-d.score),{sequence:e,labels:u.map(d=>d.label),scores:u.map(d=>d.score),processingTime:performance.now()-i}}async scoreHypothesis(e,s){if(!this.tokenizer)throw new Error("Tokenizer not set. Call setTokenizer() first.");return this.tokenizer.encode(e,{textPair:s,addSpecialTokens:!0,maxLength:512,truncation:!0,returnAttentionMask:!0,returnTokenTypeIds:!0}),Math.random()}async preprocess(e){let{text:s,candidateLabels:n}=e,o=Array.isArray(s)?s[0]??"":s,i=n[0]??"";if(!this.tokenizer)return[new m(new Float32Array([0]),[1],"float32")];let a=this.tokenizer.encode(o,{textPair:this.hypothesisTemplate.replace("{label}",i),addSpecialTokens:!0,maxLength:512});return[new m(BigInt64Array.from(a.inputIds.map(c=>BigInt(c))),[1,a.inputIds.length],"int64")]}async postprocess(e,s){return{sequence:"",labels:[],scores:[]}}};var Ne=class extends S{constructor(e){super(e??{task:"question-answering",model:"default"});h(this,"tokenizer",null)}setTokenizer(e){this.tokenizer=e}async run(e,s){await this.initialize();let n=Array.isArray(e)?e:[e],o=await Promise.all(n.map(i=>this.answerQuestion(i,s??{})));return Array.isArray(e)?o:o[0]}async answerQuestion(e,s){let n=performance.now();if(!this.tokenizer)throw new Error("Tokenizer not set. Call setTokenizer() first.");let{question:o,context:i}=e,{maxAnswerLength:a=30}=s,c=this.tokenizer.encode(o,{textPair:i,addSpecialTokens:!0,maxLength:512,truncation:!0,returnAttentionMask:!0,returnTokenTypeIds:!0}),l=this.findBestAnswer(i,o,c.inputIds,a);return{answer:l.text,score:l.score,start:l.start,end:l.end,processingTime:performance.now()-n}}findBestAnswer(e,s,n,o){let i=s.toLowerCase().split(/\s+/),a=e.split(/[.!?]+/).filter(p=>p.trim()),c="",l=0,u=0;for(let p of a){let x=p.toLowerCase().split(/\s+/),T=0;for(let y of i)x.some(b=>b.includes(y)||y.includes(b))&&(T+=1);T>l&&(l=T,c=p.trim(),u=e.indexOf(p.trim()))}let d=c.split(/\s+/);d.length>o&&(c=d.slice(0,o).join(" "));let f=i.length>0?l/i.length:0;return{text:c||"No answer found",score:Math.min(f,1),start:u>=0?u:0,end:u>=0?u+c.length:0}}async preprocess(e){if(!this.tokenizer)return[new m(new Float32Array([0]),[1],"float32")];let s=Array.isArray(e)?e[0]:e,n=this.tokenizer.encode(s.question,{textPair:s.context,addSpecialTokens:!0,maxLength:512,truncation:!0,returnAttentionMask:!0,returnTokenTypeIds:!0});return[new m(BigInt64Array.from(n.inputIds.map(o=>BigInt(o))),[1,n.inputIds.length],"int64"),new m(BigInt64Array.from(n.attentionMask.map(o=>BigInt(o))),[1,n.attentionMask.length],"int64")]}async postprocess(e,s){if(e.length<2)return{answer:"",score:0,start:0,end:0};let n=e[0].toFloat32Array(),o=e[1].toFloat32Array(),i=n.length,a=E(new m(n,[i],"float32")).toFloat32Array(),c=E(new m(o,[i],"float32")).toFloat32Array(),l=0,u=0,d=0;for(let f=0;f<i;f++)for(let p=f;p<Math.min(f+30,i);p++){let x=(a[f]??0)*(c[p]??0);x>d&&(d=x,l=f,u=p)}return{answer:"",score:d,start:l,end:u}}};async function Ft(r,t){let e={task:r,model:t?.model??"default",runtime:t?.runtime,cache:t?.cache??!0,quantization:t?.quantization},s;switch(r){case"text-classification":s=new q(e,t?.labels);break;case"sentiment-analysis":s=new W(e);break;case"feature-extraction":s=new H(e);break;case"image-classification":s=new G(e,t?.labels);break;case"text-generation":s=new Ee(e);break;case"object-detection":s=new _e(e,t?.labels);break;case"automatic-speech-recognition":s=new De(e);break;case"zero-shot-classification":s=new Pe(e);break;case"question-answering":s=new Ne(e);break;default:throw new Error(`Unknown pipeline task: ${r}`)}return await s.initialize(),s}async function Ls(r,t){let e=await Promise.all(r.map(n=>Ft(n,t))),s={};for(let n=0;n<r.length;n++){let o=r[n];s[o]=e[n]}return s}xe();xe();var Os="https://huggingface.co",Rs="main",Ct=["model.onnx","model_quantized.onnx","model_int8.onnx","model_uint8.onnx","model_fp16.onnx","onnx/model.onnx","onnx/model_quantized.onnx"];function ve(r,t,e={}){let s=e.endpoint??Os,n=e.revision??Rs,o=e.subfolder?`${e.subfolder}/`:"";return`${s}/${r}/resolve/${n}/${o}${t}`}async function Lt(r,t){let e={};return t&&(e.Authorization=`Bearer ${t}`),await fetch(r,{headers:e})}async function Ot(r,t,e={}){let s=ve(r,t,e);try{let n=await Lt(s,e.token);return n.ok||n.status===302}catch{return!1}}async function ot(r,t={}){for(let e of Ct)if(await Ot(r,e,t))return e;return null}async function Rt(r,t,e={}){let s=ve(r,t,e);return Q(s,{cache:e.cache??!0,forceDownload:e.forceDownload??!1,onProgress:e.onProgress?n=>{e.onProgress({file:t,fileIndex:1,totalFiles:1,fileProgress:n,overallProgress:n.percent})}:void 0})}async function Bs(r,t,e={}){let s=ve(r,t,e);if(e.cache!==!1&&!e.forceDownload&&await ce(s)){let i=await Q(s,{cache:!0}),a=new TextDecoder().decode(i);return JSON.parse(a)}let n=await Lt(s,e.token);if(!n.ok)throw new g(`Failed to download ${t} from ${r}: ${n.status}`,w.MODEL_NOT_FOUND);return n.json()}async function rt(r,t={}){let e=ve(r,"tokenizer.json",t);return U.fromUrl(e)}async function Fe(r,t={}){return Bs(r,"config.json",t)}async function Ce(r,t={}){let e={},n=0,o=(u,d)=>{if(t.onProgress){let f=n/3*100,p=d.percent/3;t.onProgress({file:u,fileIndex:n+1,totalFiles:3,fileProgress:d,overallProgress:f+p})}};console.log(`\u{1F50D} Finding ONNX model in ${r}...`);let i=await ot(r,t);if(!i)throw new g(`No ONNX model found in ${r}. Please ensure the model has an ONNX file.`,w.MODEL_NOT_FOUND,{modelId:r,triedFiles:Ct});e.model=i,console.log(`\u{1F4E6} Downloading model: ${i}`);let a=await Rt(r,i,{...t,onProgress:u=>o(i,u.fileProgress)});n=1;let c;try{console.log("\u{1F4DD} Downloading tokenizer..."),e.tokenizer="tokenizer.json",c=await rt(r,t),console.log("\u2713 Tokenizer loaded")}catch{console.warn(`\u26A0\uFE0F No tokenizer found for ${r}`)}n=2;let l;try{console.log("\u2699\uFE0F Downloading config..."),e.config="config.json",l=await Fe(r,t),console.log("\u2713 Config loaded")}catch{console.warn(`\u26A0\uFE0F No config found for ${r}`)}return n=3,t.onProgress&&t.onProgress({file:"complete",fileIndex:3,totalFiles:3,fileProgress:{loaded:1,total:1,percent:100,speed:0,eta:0},overallProgress:100}),console.log(`\u2705 Model bundle downloaded: ${r}`),{modelId:r,modelData:a,tokenizer:c,config:l,files:e}}async function Bt(r,t={}){return Ce(r,t)}async function Ut(r,t={}){try{return await ot(r,t)!==null}catch{return!1}}async function qt(r,t={}){let[e,s,n]=await Promise.all([ot(r,t),Ot(r,"tokenizer.json",t),Fe(r,t).catch(()=>{})]);return{hasOnnx:e!==null,onnxFile:e??void 0,hasTokenizer:s,hasConfig:n!==void 0,config:n}}var it={"sentiment-analysis":"Xenova/distilbert-base-uncased-finetuned-sst-2-english","text-classification":"Xenova/distilbert-base-uncased-finetuned-sst-2-english","feature-extraction":"Xenova/all-MiniLM-L6-v2","sentence-similarity":"Xenova/all-MiniLM-L6-v2","question-answering":"Xenova/distilbert-base-cased-distilled-squad",ner:"Xenova/bert-base-NER","token-classification":"Xenova/bert-base-NER","text-generation":"Xenova/gpt2","translation-en-fr":"Xenova/t5-small","translation-en-de":"Xenova/t5-small",summarization:"Xenova/distilbart-cnn-6-6","fill-mask":"Xenova/bert-base-uncased","image-classification":"Xenova/vit-base-patch16-224","object-detection":"Xenova/detr-resnet-50","image-segmentation":"Xenova/segformer-b0-finetuned-ade-512-512","zero-shot-classification":"Xenova/mobilebert-uncased-mnli","automatic-speech-recognition":"Xenova/whisper-tiny.en","text-to-speech":"Xenova/speecht5_tts"};function at(r){return it[r]}async function $t(r,t={}){let e=at(r);return Ce(e,t)}async function Us(r,t){let e=r instanceof ArrayBuffer?r:await ct(r),s=e.byteLength,n,o=0,i=0;switch(t.method){case"int8":({data:n,layersQuantized:o,layersSkipped:i}=qs(e,t));break;case"uint8":({data:n,layersQuantized:o,layersSkipped:i}=$s(e,t));break;case"float16":({data:n,layersQuantized:o,layersSkipped:i}=js(e,t));break;case"int4":({data:n,layersQuantized:o,layersSkipped:i}=Ws(e,t));break;default:n=e}return{modelData:n,originalSize:s,quantizedSize:n.byteLength,compressionRatio:s/n.byteLength,stats:{layersQuantized:o,layersSkipped:i}}}async function ct(r){return new ArrayBuffer(0)}function qs(r,t){let e=new Float32Array(r),s=new Int8Array(e.length),n=0;for(let i=0;i<e.length;i++){let a=Math.abs(e[i]??0);a>n&&(n=a)}let o=n/127;for(let i=0;i<e.length;i++)s[i]=Math.round((e[i]??0)/o);return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function $s(r,t){let e=new Float32Array(r),s=new Uint8Array(e.length),n=1/0,o=-1/0;for(let a=0;a<e.length;a++){let c=e[a]??0;c<n&&(n=c),c>o&&(o=c)}let i=(o-n)/255;for(let a=0;a<e.length;a++)s[a]=Math.round(((e[a]??0)-n)/i);return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function js(r,t){let e=new Float32Array(r),s=new Uint16Array(e.length);for(let n=0;n<e.length;n++)s[n]=Hs(e[n]??0);return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function Ws(r,t){let e=new Float32Array(r),s=new Uint8Array(Math.ceil(e.length/2)),n=0;for(let i=0;i<e.length;i++){let a=Math.abs(e[i]??0);a>n&&(n=a)}let o=n/7;for(let i=0;i<e.length;i+=2){let a=Math.round((e[i]??0)/o)+8,c=Math.round((e[i+1]??0)/o)+8;s[i/2]=(a&15)<<4|c&15}return{data:s.buffer,layersQuantized:1,layersSkipped:0}}function Hs(r){let t=new Float32Array(1),e=new Int32Array(t.buffer);t[0]=r;let s=e[0]??0,n=s>>16&32768,o=s>>12&2047,i=s>>23&255;return i<103?n:i>142?(n|=31744,n|=(i===255?0:1)&&s&8388607,n):i<113?(o|=2048,n|=(o>>114-i)+(o>>113-i&1),n):(n|=i-112<<10|o>>1,n+=o&1,n)}async function Gs(r,t){let e=r instanceof ArrayBuffer?r:await ct(r),s=new Float32Array(e),n=s.length,i=[...s.map(Math.abs)].sort((u,d)=>u-d),a=Math.floor(t.sparsity*i.length),c=i[a]??0,l=0;for(let u=0;u<s.length;u++)Math.abs(s[u]??0)<c&&(s[u]=0,l++);return{modelData:s.buffer,actualSparsity:l/n,parametersPruned:l,totalParameters:n}}async function Vs(r){let t=r instanceof ArrayBuffer?r.byteLength:r.metadata.sizeBytes,e=Math.floor(t/4);return{totalParameters:e,sizeBytes:t,layers:[],estimatedFlops:e*2,memoryRequirements:{weights:t,activations:t*.1,total:t*1.1}}}async function Xs(r,t={}){let{warmupRuns:e=3,runs:s=10}=t;for(let f=0;f<e;f++)await r();let n=[];for(let f=0;f<s;f++){let p=performance.now();await r(),n.push(performance.now()-p)}let i=n.reduce((f,p)=>f+p,0)/n.length,a=Math.min(...n),c=Math.max(...n),u=n.map(f=>Math.pow(f-i,2)).reduce((f,p)=>f+p,0)/n.length,d=Math.sqrt(u);return{avgTime:i,minTime:a,maxTime:c,stdDev:d,throughput:1e3/i,times:n}}async function Qs(r,t){let e=r instanceof ArrayBuffer?r:await ct(r);switch(t){case"json":let s=new Float32Array(e);return JSON.stringify(Array.from(s));case"binary":case"onnx":default:return e}}async function mr(){let r=await de();return Array.from(r.values()).some(t=>t)}async function gr(){let r=await de();return r.get("webgpu")?"webgpu":r.get("webnn")?"webnn":r.get("wasm")?"wasm":null}async function wr(r){let t=new j;await Promise.all(r.map(async e=>{if(!await t.get(e)){let s=await fetch(e);s.ok&&await t.put(e,s)}}))}var Ks="0.1.0";async function yr(){let r=await de();return{version:Ks,runtimes:{webgpu:r.get("webgpu")??!1,webnn:r.get("webnn")??!1,wasm:r.get("wasm")??!1,auto:!0},features:["concurrent-execution","batch-processing","memory-management","model-caching","quantization"]}}export{J as AudioPreprocessor,S as BasePipeline,se as Cache,Mt as EMOTION_LABELS,g as EdgeFlowError,m as EdgeFlowTensor,w as ErrorCodes,H as FeatureExtractionPipeline,Se as IMAGENET_LABELS,G as ImageClassificationPipeline,Y as ImagePreprocessor,Me as InferenceCache,oe as InferenceScheduler,C as LoadedModelImpl,X as MemoryManager,re as MemoryScope,ie as ModelCache,j as ModelDownloadCache,it as POPULAR_MODELS,F as RuntimeManager,ge as SENTIMENT_LABELS,W as SentimentAnalysisPipeline,q as TextClassificationPipeline,U as Tokenizer,Ks as VERSION,pe as WASMRuntime,he as WebGPURuntime,fe as WebNNRuntime,rs as add,Vs as analyzeModel,ss as arange,ds as argmax,Xs as benchmark,Ye as cancelPreload,Xe as clearModelCache,hs as concat,gs as configureScheduler,Nt as createAudioPreprocessor,ne as createBasicTokenizer,At as createCache,Dt as createFeatureExtractionPipeline,vt as createImageClassificationPipeline,ze as createImagePreprocessor,Ls as createPipelines,_t as createSentimentAnalysisPipeline,Et as createTextClassificationPipeline,wt as createWASMRuntime,ke as createWebGPURuntime,Ae as createWebNNRuntime,Ve as deleteCachedModel,dt as div,Fe as downloadConfig,Ce as downloadModel,rt as downloadTokenizer,Qs as exportModel,os as eye,Bt as fromHub,$t as fromTask,Zt as full,As as gc,de as getAvailableRuntimes,Ns as getBestRuntime,gr as getBestRuntimeType,Ge as getCachedModel,at as getDefaultModel,yr as getInfo,N as getMemoryManager,Ts as getMemoryStats,Qe as getModelCacheStats,qt as getModelInfo,It as getPipelineFactory,Ke as getPreloadStatus,Je as getPreloadedModel,Ps as getRuntimeManager,ye as getScheduler,ce as isModelCached,mr as isSupported,ns as linspace,et as loadModel,Q as loadModelData,_s as loadModelFromBuffer,St as loadTokenizer,zt as loadTokenizerFromHub,cs as matmul,us as mean,Ut as modelExists,as as mul,Jt as ones,Ft as pipeline,wr as preload,We as preloadModel,He as preloadModels,Pt as preprocessText,Gs as prune,Us as quantize,ts as randn,es as random,kt as registerAllBackends,B as registerPipeline,ue as registerRuntime,ks as release,Re as relu,Ds as runBatchInference,le as runInference,ft as setScheduler,Be as sigmoid,E as softmax,is as sub,Oe as sum,ls as tanh,Yt as tensor,ys as withMemoryScope,xs as withMemoryScopeSync,ut as zeros};
//# sourceMappingURL=edgeflow.browser.min.js.map
